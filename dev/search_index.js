var documenterSearchIndex = {"docs":
[{"location":"simplebp/#Simple-bifurcation-branch-point","page":"Simple branch point","title":"Simple bifurcation branch point","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"A simple branch point (x_0p_0) for the problem F(xp)=0 satisfies dim ker dF(x_0p_0) = 1. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a scalar polynomial (delta p equiv p-p_0): ","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"adelta p + zleft(b_1delta p + fracb_22z + fracb_36z^2right) = 0 tagE","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"whose solutions give access to all solutions in a neighborhood of (xp).","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"More precisely, if ker dF(x_0p_0) = mathbb Rzeta, one can show that x_0+zzeta is close to a solution on a new branch, thus satisfying F(x_0+zzetap_0+delta p)approx 0.","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"In the above scalar equation,","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"if aneq 0, this is a Saddle-Node bifurcation\nif a=0b_2neq 0, the bifurcation point is a Transcritical one where the bifurcated branch exists on each side of p.\nif a=0b_2=0 b_3neq 0, the bifurcation point is a Pitchfork one where the bifurcated branch only exists on one side of p. If it exists at smaller values then p, this is a subcritical Pitchfork bifurcation. In the other case, this is a supercritical Pitchfork bifurcation.","category":"page"},{"location":"simplebp/#Normal-form-computation","page":"Simple branch point","title":"Normal form computation","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"get_normal_form(br::ContResult, ind_bif::Int ;\n\tverbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"where prob is the bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns the following:","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"mutable struct SimpleBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvector(s)\"\n\tζ::Tevr\n\n\t\"Left eigenvector(s)\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"eigensolver/#Eigen-solvers-(Eig)","page":"Eigen Solvers","title":"Eigen solvers (Eig)","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"See also Eigen solvers for more information, for example on how to implement your own.","category":"page"},{"location":"eigensolver/#List-of-implemented-eigen-solvers","page":"Eigen Solvers","title":"List of implemented eigen solvers","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen Solvers","title":"Eigen Solvers","text":"Default DDE_DefaultEig eigensolver for DDE. You can create it via eig = DDE_DefaultEig(). It is based on the package NonlinearEigenproblems.jl.","category":"page"},{"location":"periodicOrbit/#Periodic-orbits-computation","page":"Introduction","title":"Periodic orbits computation","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"Consider the DDE problem written","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"fracdudt=F(u(t) u_tp)tagE","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"A periodic solution u^* with period T satisfies u^*(t+T)=u^*(t) for all time t.","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"We provide 1 method for computing periodic orbits (PO):","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"one (Collocation) based on orthogonal collocation to discretize the above problem (E),","category":"page"},{"location":"periodicOrbit/#Important-notes","page":"Introduction","title":"Important notes","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"We regroup here some important notes which are valid for all methods above. ","category":"page"},{"location":"periodicOrbit/#1.-Finaliser","page":"Introduction","title":"1. Finaliser","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"If you pass a finalize function to continuation, the following occurs:","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"If the newton solve was successfull, we update the phase condition every update_section_every_step\nwe call the user defined finalizer finalize.","category":"page"},{"location":"tutorials/dde/neuronV2/#(Another)-Neuron-model-(codim-2,-periodic-orbits)","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"","category":"section"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"Pages = [\"neuronV2.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"Consider the neuron model","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"beginaligned\n dotx_1(t)=-x_1(t)-a gleft(b x_1left(t-tau_1right)right)+c gleft(d x_2left(t-tau_2right)right) \n dotx_2(t)=-x_2(t)-a gleft(b x_2left(t-tau_1right)right)+c gleft(d x_1left(t-tau_2right)right)\nendaligned","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"where g(z)=tanh (z-1)+tanh (1) cosh (1)^2. ","category":"page"},{"location":"tutorials/dde/neuronV2/#Continuation-and-codim-1-bifurcations","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Continuation and codim 1 bifurcations","text":"","category":"section"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"We first instantiate the model","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"using Revise, DDEBifurcationKit, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\ng(z) = (tanh(z − 1) + tanh(1))*cosh(1)^2\nfunction neuron2VF(x, xd, p)\n   (; a,b,c,d) = p\n   [\n      -x[1] - a * g(b*xd[1][1]) + c * g(d*xd[2][2]),\n      -x[2] - a * g(b*xd[1][2]) + c * g(d*xd[2][1])\n   ]\nend\n\nfunction delaysF(par)\n   [par.τ1, par.τ2]\nend\n\npars = (a = 0.25, b = 2., c = 15/29, d = 1.2, τ1 = 12.7, τ2 = 20.2)\nx0 = [0.01, 0.001]\n\nprob = ConstantDDEBifProblem(neuron2VF, delaysF, x0, pars, (@optic _.a))\n\noptn = NewtonPar(verbose = false, eigsolver = DDE_DefaultEig(maxit=100))\nopts = ContinuationPar(p_max = 1., p_min = 0., newton_options = optn, ds = 0.01, detect_bifurcation = 3, nev = 9, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob, PALC(tangent=Bordered()), opts)","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"We then plot the branch","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"scene = plot(br)","category":"page"},{"location":"tutorials/dde/neuronV2/#Normal-forms-computation","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Normal forms computation","text":"","category":"section"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"As in BifurcationKit.jl, it is straightforward to compute the normal forms.","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"hopfpt = BK.get_normal_form(br, 2)","category":"page"},{"location":"tutorials/dde/neuronV2/#Continuation-of-Hopf-points","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"We follow the Hopf points in the parameter plane (ac). We tell the solver to consider br.specialpoint[1] and continue it.","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"# continuation of the first Hopf point\nbrhopf = continuation(br, 1, (@optic _.c),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.01, max_steps = 100, p_max = 1.1, p_min = -0.1,ds = 0.01, n_inversion = 2);\n         verbosity = 0,\n         detect_codim2_bifurcation = 2,\n         bothside = true,\n         start_with_eigen = true)\n\nbrhopf2 = continuation(br, 2, (@optic _.c),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.01, max_steps = 100, p_max = 1.1, p_min = -0.1,ds = -0.01);\n         verbosity = 0,\n         detect_codim2_bifurcation = 2,\n         bothside = true,\n         start_with_eigen = true)\n\nscene = plot(brhopf, vars = (:a, :c), xlims = (0,0.7), ylims = (0,1))\nplot!(scene, brhopf2, vars = (:a, :c), xlims = (-0,0.7), ylims = (-0.1,1))\nscene","category":"page"},{"location":"tutorials/dde/neuronV2/#Continuation-of-Fold-points","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Continuation of Fold points","text":"","category":"section"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"We follow the Fold points in the parameter plane (a c). We tell the solver to consider br2.specialpoint[3] and continue it.","category":"page"},{"location":"tutorials/dde/neuronV2/","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"prob2 = ConstantDDEBifProblem(neuron2VF, delaysF, x0, (pars..., a = 0.12), (@optic _.c))\nbr2 = continuation(prob2, PALC(), ContinuationPar(opts, p_max = 1.22);)\n\n\n# change tolerance for avoiding error computation of the EV\nopts_fold = br.contparams\n@reset opts_fold.newton_options.eigsolver.σ = 1e-7\n\nbrfold = continuation(br2, 3, (@optic _.a),\n         ContinuationPar(opts_fold; detect_bifurcation = 1, dsmax = 0.01, max_steps = 70, p_max = 0.6, p_min = -0.6,ds = -0.01, n_inversion = 2, tol_stability = 1e-6);\n         verbosity = 1, plot = true,\n         detect_codim2_bifurcation = 2,\n         update_minaug_every_step = 1,\n         bothside = false,\n         start_with_eigen = true)\n\nscene = plot(brfold, vars = (:a, :c), branchlabel = \"Fold\")\nplot!(scene, brhopf, vars = (:a, :c), branchlabel = \"Hopf\")\nplot!(scene, brhopf2, vars = (:a, :c), branchlabel = \"Hopf\")\nscene","category":"page"},{"location":"codim2Continuation/#Fold-/-Hopf-Continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"In this page, we explain how to perform continuation of Fold / Hopf points and detect the associated bifurcations.","category":"page"},{"location":"codim2Continuation/#List-of-detected-codim-2-bifurcation-points","page":"Fold / Hopf Continuation (codim 2)","title":"List of detected codim 2 bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Bifurcation symbol used\nBogdanov-Takens bt\nBautin gh\nCusp cusp\nZero-Hopf zh\nHopf-Hopf hh","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"In a nutshell, all you have to do (see below) is to call continuation(br, ind_bif, lens2) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options.","category":"page"},{"location":"codim2Continuation/#Fold-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Fold continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities. See docs in BifurcationKit for more information.","category":"page"},{"location":"codim2Continuation/#Detection-of-codim-2-bifurcation-points","page":"Fold / Hopf Continuation (codim 2)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"the detection of Cusp (Cusp) is done by the detection of Fold bifurcation points along the curve of Folds by monitoring the parameter component of the tangent.\nthe detection of Bogdanov-Takens (BT) is performed using the test function[Bindel] psi_BT(p) = langle w(p)v(p)rangle\nthe detection of Zero-Hopf (ZH) is performed by monitoring the number of eigenvalues lambda such that Relambda  minlimits_nuinSigma(dF)Renu and Imlambda  epsilon where epsilon is the Newton tolerance.","category":"page"},{"location":"codim2Continuation/#Hopf-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Hopf continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"The continuation of Fold bifurcation points is based on solving the extended system for (u^* v omega)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"beginaligned\n 0=mathbf Fleft(u^* u^* pright) \n 0=Deltaleft(u^* p mathrmi omegaright) v \n 0=v^mathrmH v-1\nendaligned","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where Delta(lambda)cdot v = lambda v - d_1mathbf F(u^*u^* p)cdot v-d_2mathbf F(u^* u^* p)cdot(e^lambdacdotv).","category":"page"},{"location":"codim2Continuation/#Detection-of-codim-2-bifurcation-points-2","page":"Fold / Hopf Continuation (codim 2)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"the detection of Bogdanov-Takens (BT) is performed using the test function psi_BT(p) = \tomega\nthe detection of Bautin (GH) is based on the test function psi_GH(p) = Re(l_1(p)) where l_1 is the Lyapunov coefficient defined in Simple Hopf point.\nthe detection of Zero-Hopf (ZH) is performed by monitoring the eigenvalues.\nthe detection of Hopf-Hopf (HH) is performed by monitoring the eigenvalues.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"The continuation of Hopf points is stopped at BT and when omega100epsilon where epsilon is the newton tolerance.","category":"page"},{"location":"codim2Continuation/#Codim-2-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"To compute the codim 2 curve of Fold / Hopf points, one can call continuation with the following options","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/#BifurcationKit.NewtonPar","page":"Library","title":"BifurcationKit.NewtonPar","text":"struct NewtonPar{T, L<:BifurcationKit.AbstractLinearSolver, E<:AbstractEigenSolver}\n\nReturns a variable containing parameters to affect the newton algorithm when solving F(x) = 0.\n\nArguments (with default values):\n\ntol::Any: absolute tolerance for F(x) Default: 1.0e-12\nmax_iterations::Int64: number of Newton iterations Default: 25\nverbose::Bool: display Newton iterations? Default: false\nlinsolver::BifurcationKit.AbstractLinearSolver: linear solver, must be <: AbstractLinearSolver Default: DefaultLS()\neigsolver::AbstractEigenSolver: eigen solver, must be <: AbstractEigenSolver Default: DefaultEig()\nlinesearch::Bool: Default: false\nα::Any: Default: convert(typeof(tol), 1.0)\nαmin::Any: Default: convert(typeof(tol), 0.001)\n\nArguments for line search (Armijo)\n\nlinesearch = false: use line search algorithm (i.e. Newton with Armijo's rule)\nα = 1.0: initial value of α (damping) parameter for line search algorithm\nαmin  = 0.001: minimal value of the damping alpha\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Accessors.jl to drastically simplify the mutation of different fields. See the tutorials for examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#BifurcationKit.ContinuationPar","page":"Library","title":"BifurcationKit.ContinuationPar","text":"options = ContinuationPar(dsmin = 1e-4,...)\n\nReturns a variable containing parameters to affect the continuation algorithm used to solve F(x, p) = 0.\n\nArguments\n\ndsmin, dsmax are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.\nds = 0.01 is the initial arclength.\np_min, p_max allowed parameter range for p\nmax_steps = 100 maximum number of continuation steps\nnewton_options::NewtonPar: options for the Newton algorithm\nsave_to_file = false: save to file. A name is automatically generated or can be defined in continuation. This requires using JLD2.\nsave_sol_every_step::Int64 = 0 at which continuation steps do we save the current solution\nplot_every_step = 10 at which continuation steps do we plot the current solution\n\nHandling eigen elements, their computation is triggered by the argument detect_bifurcation (see below)\n\nnev = 3 number of eigenvalues to be computed. It is automatically increased to have at least nev unstable eigenvalues. To be set for proper  bifurcation detection. See Detection of bifurcation points of Equilibria for more informations.\nsave_eig_every_step = 1 record eigen vectors every specified steps. Important for memory limited resource, e.g. GPU.\nsave_eigenvectors = true Important for memory limited resource, e.g. GPU.\n\nHandling bifurcation detection\n\ntol_stability = 1e-10 lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits\ndetect_fold = true detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndetect_bifurcation::Int ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)\ndsmin_bisection = 1e-16 dsmin for the bisection algorithm for locating bifurcation points\nn_inversion = 2 number of sign inversions in bisection algorithm\nmax_bisection_steps = 15 maximum number of bisection steps\ntol_bisection_eigenvalue = 1e-16 tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps\n\nHandling ds adaptation (see continuation for more information)\n\na  = 0.5 aggressiveness factor. It is used to adapt ds in order to have a number of newton iterations per continuation step roughly constant. The higher a is, the larger the step size ds is changed at each continuation step.\n\nHandling event detection\n\ndetect_event::Int ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are sought during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).\ntol_param_bisection_event = 1e-16 tolerance on parameter to locate event\n\nMisc\n\nη = 150. parameter to estimate tangent at first point with parameter  p₀ + ds / η\ndetect_loop [WORK IN PROGRESS] detect loops in the branch and stop the continuation\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Accessors.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/#DDEBifurcationKit.ConstantDDEBifProblem","page":"Library","title":"DDEBifurcationKit.ConstantDDEBifProblem","text":"struct ConstantDDEBifProblem{Tvf, Tdf, Tu, Td, Tp, Tl<:Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}, Tplot, Trec, Tgets, Tδ} <: DDEBifurcationKit.AbstractDDEBifurcationProblem\n\nStructure to hold the bifurcation problem. If don't have parameters, you can pass nothing.\n\nFields\n\nVF::Any: Vector field, typically a BifFunction. For more information, please look at the website https://bifurcationkit.github.io/DDEBifurcationKit.jl/dev/BifProblem\ndelays::Any: function delays. It takes the parameters and return the non-zero delays in an AbstractVector form. Example: delays = par -> [1.]\nu0::Any: Initial guess\ndelays0::Any: initial delays (set internally by the constructor)\nparams::Any: parameters\nlens::Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}: Typically a Accessors.@optic. It specifies which parameter axis among params is used for continuation. For example, if par = (α = 1.0, β = 1), we can perform continuation w.r.t. α by using lens = (@optic _.α). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@optic _[1]). For more information, we refer to Accessors.jl.\nplotSolution::Any: user function to plot solutions during continuation. Signature: plotSolution(x, p; kwargs...)\nrecordFromSolution::Any: record_from_solution = (x, p; k...) -> norm(x) function used record a few indicators about the solution. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch (see below). Finally, the first component is used to plot in the continuation curve.\nsave_solution::Any: function to save the full solution on the branch. Some problem are mutable (like periodic orbit functional with adaptive mesh) and this function allows to save the state of the problem along with the solution itself. Signature save_solution(x, p)\nδ::Any: delta for Finite differences\n\nMethods\n\ngetu0(pb) calls pb.u0\ngetparams(pb) calls pb.params\ngetlens(pb) calls pb.lens\nsetparam(pb, p0) calls set(pb.params, pb.lens, p0)\nrecord_from_solution(pb) calls pb.record_from_solution\n\nConstructors\n\nConstantDDEBifProblem(F, delays, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...) and kwargs are the fields above.\n\n\n\n\n\n","category":"type"},{"location":"library/#DDEBifurcationKit.SDDDEBifProblem","page":"Library","title":"DDEBifurcationKit.SDDDEBifProblem","text":"struct SDDDEBifProblem{Tvf, Tdf, Tu, Td, Tp, Tl<:Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}, Tplot, Trec, Tgets, Tδ} <: DDEBifurcationKit.AbstractDDEBifurcationProblem\n\nStructure to hold the bifurcation problem. If don't have parameters, you can pass nothing.\n\nFields\n\nVF::Any: Vector field, typically a BifFunction. For more information, please look at the website https://bifurcationkit.github.io/DDEBifurcationKit.jl/dev/BifProblem\ndelays::Any: function delays. It takes the parameters and the state and return the non-zero delays in an AsbtractVector form. Example: delays = (par, u) -> [1. + u[1]^2]\nu0::Any: Initial guess\ndelays0::Any: initial delays (set internally by the constructor)\nparams::Any: parameters\nlens::Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}: see ConstantDDEBifProblem for more information.\nplotSolution::Any: user function to plot solutions during continuation. Signature: plotSolution(x, p; kwargs...)\nrecordFromSolution::Any: record_from_solution = (x, p; k...) -> norm(x) function used record a few indicators about the solution. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch (see below). Finally, the first component is used to plot in the continuation curve.\nsave_solution::Any: function to save the full solution on the branch. Some problem are mutable (like periodic orbit functional with adaptive mesh) and this function allows to save the state of the problem along with the solution itself. Signature save_solution(x, p)\nδ::Any: delta for Finite differences\n\nMethods\n\ngetu0(pb) calls pb.u0\ngetparams(pb) calls pb.params\ngetlens(pb) calls pb.lens\nsetparam(pb, p0) calls set(pb.params, pb.lens, p0)\nrecord_from_solution(pb) calls pb.record_from_solution\n\nConstructors\n\nSDDDEBifProblem(F, delays, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...) and kwargs are the fields above.\n\n\n\n\n\n","category":"type"},{"location":"library/#Eigen-solvers","page":"Library","title":"Eigen solvers","text":"","category":"section"},{"location":"library/#DDEBifurcationKit.DDE_DefaultEig","page":"Library","title":"DDEBifurcationKit.DDE_DefaultEig","text":"mutable struct DDE_DefaultEig{T, Tw, Tv} <: DDEBifurcationKit.AbstractDDEEigenSolver\n\nDefault eigen solver for DDEBifurcationKit based on the julia package NonlinearEigenproblems.jl. ore precisely, we rely on NonlinearEigenproblems.iar_chebyshev for the computation of eigenvalues.\n\nFields\n\nmaxit::Int64: Default: 100\nwhich::Any: Default: real\nσ::Any: Default: 0.0\nγ::Any: Default: 1.0\ntol::Any: Default: 1.0e-10\nlogger::Int64: Default: 0\ncheck_error_every::Int64: Default: 1\nv::Any: Default: nothing\n\nConstructors\n\nDDE_DefaultEig(; kwargs...) and kwargs are the fields above.\n\n\n\n\n\n","category":"type"},{"location":"library/#Branch-switching-(branch-point)","page":"Library","title":"Branch switching (branch point)","text":"","category":"section"},{"location":"library/#Branch-switching-(Hopf-point)","page":"Library","title":"Branch switching (Hopf point)","text":"","category":"section"},{"location":"library/#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}","page":"Library","title":"BifurcationKit.continuation","text":"continuation(\n    br,\n    ind_bif,\n    _contParams,\n    pbPO;\n    bif_prob,\n    alg,\n    δp,\n    ampfactor,\n    usedeflation,\n    detailed,\n    use_normal_form,\n    autodiff_nf,\n    nev,\n    kwargs...\n)\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points of a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprobPO problem used to specify the way toc compute the periodic orbit. It can be PeriodicOrbitTrapProblem, PeriodicOrbitOCollProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nalg = br.alg continuation algorithm\nδp used to specify the guess for the parameter on the bifurcated branch which otherwise defaults to contParams.ds. This allows to use an initial step larger than contParams.dsmax.\nampfactor = 1 multiplicative factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nuse_normal_form = true whether to use the normal form in order to compute the predictor. When false, ampfactor and δp are used to make a predictor based on the bifurcating eigenvector. Setting use_normal_form = false can be useful when computing the normal form is not possible for example when higher order derivatives are not available.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nnev number of eigenvalues to be computed to get the right eigenvector\nautodiff_nf = true whether to use autodiff in get_normal_form. This can be used in case automatic differentiation is not working as intented.\nall kwargs from continuation\n\nA modified version of prob is passed to plot_solution and finalise_solution.\n\nnote: Linear solver\nYou have to be careful about the options contParams.newton_options.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\n\n\n\n\n","category":"method"},{"location":"library/#Utils-for-periodic-orbits","page":"Library","title":"Utils for periodic orbits","text":"","category":"section"},{"location":"library/#BifurcationKit.getperiod","page":"Library","title":"BifurcationKit.getperiod","text":"getperiod(, x)\ngetperiod(, x, par)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetperiod(prob, x, p)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetperiod(psh, x_bar, par)\n\n\nCompute the period of the periodic orbit associated to x_bar.\n\n\n\n\n\n","category":"function"},{"location":"library/#Misc.","page":"Library","title":"Misc.","text":"","category":"section"},{"location":"library/#BifurcationKit.get_normal_form","page":"Library","title":"BifurcationKit.get_normal_form","text":"get_normal_form(\n    prob,\n    br,\n    id_bif;\n    nev,\n    verbose,\n    lens,\n    Teigvec,\n    scaleζ,\n    detailed,\n    autodiff,\n    ζs,\n    ζs_ad,\n    bls,\n    bls_adjoint,\n    bls_block\n)\n\n\nCompute the normal form of the bifurcation point located at br.specialpoint[ind_bif].\n\nArguments\n\nprob::AbstractBifurcationProblem\nbr result from a call to continuation\nind_bif index of the bifurcation point in br.specialpoint\n\nOptional arguments\n\nnev number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.\nverbose whether to display information\nζs list of vectors spanning the kernel of dF at the bifurcation point. Useful to enforce the basis for the normal form.\nlens::Lens specify which parameter to take the partial derivative ∂pF\nscaleζ function to normalise the kernel basis. Indeed, when used with large vectors and norm, it results in ζs and the normal form coefficient being super small.\nautodiff = true whether to use ForwardDiff for the differentiations w.r.t the parameters that are required to compute the normal form. Used for example for Bogdanov-Takens point. You can set to autodiff = false if you wish.\ndetailed = true whether to compute only a simplified normal form. Used for example for Bogdanov-Takens point.\nbls = MatrixBLS() specify Bordered linear solver. Used for example for Bogdanov-Takens point.\nbls_adjoint = bls specify Bordered linear solver for the adjoint problem.\nbls_block = bls specify Bordered linear solver when the border has dimension 2 (1 for bls).\n\nAvailable method\n\nYou can directly call \n\nget_normal_form(br, ind_bif ; kwargs...)\n\nwhich is a shortcut for get_normal_form(getprob(br), br, ind_bif ; kwargs...).\n\nOnce the normal form nf has been computed, you can call predictor(nf, δp) to obtain an estimate of the bifurcating branch.\n\n\n\n\n\nget_normal_form(\n    prob,\n    br,\n    id_bif;\n    nev,\n    verbose,\n    ζs,\n    lens,\n    Teigvec,\n    scaleζ,\n    autodiff,\n    δ,\n    k...\n)\n\n\nCompute the normal form (NF) of periodic orbits. We detail the additional keyword arguments specific to periodic orbits\n\nOptional arguments\n\nprm = true compute the normal form using Poincaré return map (PRM). If false, use the Iooss normal form. \nnev = length(eigenvalsfrombif(br, id_bif)),\nverbose = false,\nζs = nothing, pass the eigenvectors\nlens = getlens(br),\nTeigvec = _getvectortype(br) type of the eigenvectors (can be useful for GPU)\nscaleζ = norm, scale the eigenvector\nprm = true NF based on Poincare return map (prm=true) or Iooss' method.\nautodiff = false use autodiff or finite differences in some part of the normal form computation\ndetailed = true to get detailed normal form\nδ = getdelta(prob) delta used for finite differences\n\nNotes\n\nFor collocation, the default method to compute the NF of Period-doubling and Neimark-Sacker bifurcations is Iooss' method.\n\n\n\n\n\n","category":"function"},{"location":"nonsimplebp/#Non-simple-branch-point","page":"Non-simple branch point","title":"Non-simple branch point","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"tip: Example\nAn example of use of the methods presented here is provided in 2d generalized Bratu–Gelfand problem.    ","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"We expose our method to study non-simple branch points. Such branch point (x_0p_0) for the problem F(xp)=0 satisfies d=dim ker dF(x_0p_0)  1 and the eigenvalues have zero imaginary part. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a d-dimensional polynomial equation, called the reduced equation.","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"More precisely, it is possible to write x = u + v where uin ker dF(x_0p_0) and vapprox 0 belongs to a vector space complement of ker dF(x_0p_0). It can be shown that u solves Phi(udelta p)=0 with Phi(udelta p) = (I-Pi)F(u+psi(udelta p)p_0+delta p) where psi is known implicitly and Pi is the spectral projector on ker dF(x_0p_0). Fortunately, one can compute the Taylor expansion of Phi up to order 3. Computing the bifurcation diagram of this d-dimensional multivariate polynomials can be done using brute force methods.","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once the zeros of Phi have been located, we can use them as initial guess for continuation but for the original F !!","category":"page"},{"location":"nonsimplebp/#Reduced-equation-computation","page":"Non-simple branch point","title":"Reduced equation computation","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"get_normal_form(br::ContResult, ind_bif::Int ; verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"where prob is a bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. It returns a point with all requested information:","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"mutable struct NdBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvectors\"\n\tζ::Tevr\n\n\t\"Left eigenvectors\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"nonsimplebp/#Using-the-Reduced-equation","page":"Non-simple branch point","title":"Using the Reduced equation","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once a branch point has been computed bp = get_normal_form(...), you can do all sort of things. ","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"For example, quoted from the file test/testNF.jl, you can print the 2d reduced equation as follows:","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"julia> BifurcationKit.nf(bp2d)\n2-element Array{String,1}:\n \" + (3.23 + 0.0im) * x1 * p + (-0.123 + 0.0im) * x1^3 + (-0.234 + 0.0im) * x1 * x2^2\"\n \" + (-0.456 + 0.0im) * x1^2 * x2 + (3.23 + 0.0im) * x2 * p + (-0.123 + 0.0im) * x2^3\"","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"You can evaluate the reduced equation as bp2d(Val(:reducedForm), rand(2), 0.2). This can be used to find all the zeros of the reduced equation by sampling on a grid. \nFinally, given a d-dimensional vector x and a parameter delta p, you can have access to an initial guess u (see above) by calling bp2d(rand(2), 0.1)","category":"page"},{"location":"faq/#FAQ","page":"Frequently Asked Questions","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"See also FAQ of BifurcationKit.jl.","category":"page"},{"location":"branchswitching/#Branch-switching-page","page":"Branch switching","title":"Branch switching","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"The precise definition of the methods are given in Branch switching (branch point) and Branch switching (Hopf point).","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"Pages = [\"branchswitching.md\"]\nDepth = 3","category":"page"},{"location":"branchswitching/#Branch-switching-from-simple-branch-point-to-equilibria","page":"Branch switching","title":"Branch switching from simple branch point to equilibria","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"You can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar; kwargs...)","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"where br is a branch computed after a call to continuation with detection of bifurcation points enabled. This call computes the branch bifurcating from the ind_bifth bifurcation point in br. An example of use is provided in 2d generalized Bratu–Gelfand problem.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"See Branch switching (branch point) precise method definition","category":"page"},{"location":"branchswitching/#Simple-example","page":"Branch switching","title":"Simple example","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"using BifurcationKit, Plots\n\n# vector field of transcritical bifurcation\nF(x, p) = [x[1] * (p.μ - x[1])]\n\n# parameters of the vector field\npar = (μ = -0.2, )\n\n# problem (automatic differentiation)\nprob = BifurcationProblem(F, [0.1], par, (@optic _.μ); record_from_solution = (x, p; k...) -> x[1])\n\n# compute branch of trivial equilibria (=0) and detect a bifurcation point\nopts_br = ContinuationPar(dsmax = 0.05, ds = 0.01, detect_bifurcation = 3, nev = 2)\nbr = continuation(prob, PALC(), opts_br)\n\t\n# perform branch switching on one side of the bifurcation point\nbr1Top = continuation(br, 1, ContinuationPar(opts_br; max_steps = 14) )\n\n# on the other side\nbr1Bottom = continuation(br, 1, ContinuationPar(opts_br; ds = -opts_br.ds, max_steps = 14))\n\nscene = plot(br, br1Top, br1Bottom; branchlabel = [\"br\", \"br1Top\", \"br1Bottom\"], legend = :topleft)","category":"page"},{"location":"branchswitching/#Branch-switching-from-non-simple-branch-point-to-equilibria","page":"Branch switching","title":"Branch switching from non simple branch point to equilibria","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"We provide an automatic branch switching method in this case. The method is to first compute the reduced equation (see Non-simple branch point) and use it to compute the nearby solutions. These solutions are seeded as initial guess for continuation. Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar; kwargs...)","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"An example of use is provided in 2d generalized Bratu–Gelfand problem.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"See Branch switching (branch point) for the precise method definition","category":"page"},{"location":"branchswitching/#Branch-switching-from-Hopf-point-to-periodic-orbits","page":"Branch switching","title":"Branch switching from Hopf point to periodic orbits","text":"","category":"section"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"In order to compute the bifurcated branch of periodic solutions at a Hopf bifurcation point, you need to choose a method to compute periodic orbits among:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"Periodic orbits based on orthogonal collocation","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"Once you have decided which method to use, you use the following call:","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"continuation(br::ContResult, ind_HOPF::Int, _contParams::ContinuationPar,\n\tprob::AbstractPeriodicOrbitProblem ;\n\tδp = nothing, ampfactor = 1, kwargs...)","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"We refer to continuation for more information about the arguments. Here, we just say a few words about how we can specify prob::AbstractPeriodicOrbitProblem.","category":"page"},{"location":"branchswitching/","page":"Branch switching","title":"Branch switching","text":"For Periodic orbits based on orthogonal collocation, you can pass PeriodicOrbitOCollProblem(M, m) where M is the number of times slices in the periodic orbit and m is the degree of the collocation polynomials.","category":"page"},{"location":"simplehopf/#Simple-Hopf-point","page":"Simple Hopf","title":"Simple Hopf point","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"At a Hopf branch point (x_0p_0) for the problem F(xp)=0, the spectrum of the linear operator dF(x_0p_0) contains two purely imaginary pm iomega omega  0 which are simple. At such point, we can compute the normal form to transform the DDE problem","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"dot x = mathbfF(x_tp)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"in large dimensions to a complex polynomial vector field (delta pequiv p-p_0):","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"dot z = zleft(a cdotdelta p + iomega + l_1z^2right)quadtext(E)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"whose solutions give access to the solutions of the Cauchy problem in a neighborhood of (xp).","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"tip: Coefficient $l_1$\nThe coefficient l_1 above is called the Lyapunov coefficient","category":"page"},{"location":"simplehopf/#Normal-form-computation","page":"Simple Hopf","title":"Normal form computation","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"The normal form (E) is automatically computed as follows","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"get_normal_form(br::ContResult, ind_bif::Int ;\n\tverbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"where prob is a bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The above call returns a point with information needed to compute the bifurcated branch.","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"mutable struct Hopf{Tv, T, Tω, Tevr, Tevl, Tnf} <: BifurcationPoint\n\t\"Hopf point\"\n\tx0::Tv\n\n\t\"Parameter value at the Hopf point\"\n\tp::T\n\n\t\"Frequency of the Hopf point\"\n\tω::Tω\n\n\t\"Right eigenvector\"\n\tζ::Tevr\n\n\t\"Left eigenvector\"\n\tζstar::Tevl\n\n\t\"Normal form coefficient (a = 0., b = 1 + 1im)\"\n\tnf::Tnf\n\n\t\"Type of Hopf bifurcation\"\n\ttype::Symbol\nend","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"simplehopf/#References","page":"Simple Hopf","title":"References","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"[Haragus]: Haragus, Mariana, and Gérard Iooss. Local Bifurcations, Center Manifolds, and Normal Forms in Infinite-Dimensional Dynamical Systems. London: Springer London, 2011. https://doi.org/10.1007/978-0-85729-112-7.","category":"page"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/#Constant-delays-examples","page":"Tutorials","title":"Constant delays examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"dde/neuron.md\",\"dde/neuronV2.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#State-dependent-delays-examples","page":"Tutorials","title":"State dependent delays examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"dde/Humphries.md\",]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#Delayed-PDE-examples","page":"Tutorials","title":"Delayed PDE examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"dde/HutchinsonDiff.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/dde/Humphries/#Humphries-model-(codim-2,-periodic-orbit)","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"","category":"section"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"Pages = [\"Humphries.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"Consider the model [Hum] as an example of state-dependent delays","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"x^prime(t)=-gamma x(t)-kappa_1 xleft(t-a_1-c x(t)right)-kappa_2 xleft(t-a_2-c x(t)right)","category":"page"},{"location":"tutorials/dde/Humphries/#Continuation-and-codim-1-bifurcations","page":"Humphries model (codim 2, periodic orbit)","title":"Continuation and codim 1 bifurcations","text":"","category":"section"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"We first instantiate the model","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"using Revise, DDEBifurcationKit, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction humpriesVF(x, xd, p)\n   (;κ1,κ2,γ,a1,a2,c) = p\n   [\n      -γ * x[1] - κ1 * xd[1][1] - κ2 * xd[2][1]\n   ]\nend\n\nfunction delaysF(x, par)\n   [\n      par.a1 + par.c * x[1],\n      par.a2 + par.c * x[1],\n   ]\nend\n\n\npars = (κ1=0.,κ2=2.3,a1=1.3,a2=6,γ=4.75,c=1.)\nx0 = zeros(1)\n\nprob = SDDDEBifProblem(humpriesVF, delaysF, x0, pars, (@optic _.κ1))","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"We then compute the branch","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"optn = NewtonPar(verbose = true, eigsolver = DDE_DefaultEig())\nopts = ContinuationPar(p_max = 13., p_min = 0., newton_options = optn, ds = -0.01, detect_bifurcation = 3, nev = 3, )\nbr = continuation(prob, PALC(), opts; verbosity = 0, bothside = true)","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"and plot it","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"scene = plot(br)","category":"page"},{"location":"tutorials/dde/Humphries/#Continuation-of-Hopf-point","page":"Humphries model (codim 2, periodic orbit)","title":"Continuation of Hopf point","text":"","category":"section"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"We follow the Hopf points in the parameter plane (kappa_1kappa_2). We tell the solver to consider br.specialpoint[2] and continue it.","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"brhopf = continuation(br, 2, (@optic _.κ2),\n         ContinuationPar(br.contparams, detect_bifurcation = 2, dsmax = 0.04, max_steps = 230, p_max = 5., p_min = -1.,ds = -0.02);\n         verbosity = 0, plot = false,\n         # we disable detection of Bautin bifurcation as the\n         # Hopf normal form is not implemented for SD-DDE\n         detect_codim2_bifurcation = 0,\n         bothside = true,\n         start_with_eigen = true)\n\nscene = plot(brhopf, vars = (:κ1, :κ2))","category":"page"},{"location":"tutorials/dde/Humphries/#Branch-of-periodic-orbits","page":"Humphries model (codim 2, periodic orbit)","title":"Branch of periodic orbits","text":"","category":"section"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"We compute the branch of periodic orbits from the Hopf bifurcation points using orthogonal collocation. We use a lot of time sections N_tst=200 to have enough precision to resolve the sophisticated branch of periodic solutions especially near the first Fold point around kappa_1approx 10.","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.05, ds= 0.001, dsmin = 1e-4, p_max = 12., p_min=-5., max_steps = 3000,\n\tnev = 3, tol_stability = 1e-8, detect_bifurcation = 0, plot_every_step = 20, save_sol_every_step=1)\n@set! opts_po_cont.newton_options.tol = 1e-9\n@set! opts_po_cont.newton_options.verbose = true\n\n# arguments for periodic orbits\nargs_po = (\trecord_from_solution = (x, p; k...) -> begin\n\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\t_max = maximum(xtt[1,:])\n\t\t_min = minimum(xtt[1,:])\n\t\treturn (amp = _max - _min,\n\t\t\t\tperiod = getperiod(p.prob, x, nothing))\n\tend,\n\tplot_solution = (x, p; k...) -> begin\n\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\tplot!(xtt.t, xtt[1,:]; label = \"x\", k...)\n\t\tplot!(br; subplot = 1, putspecialptlegend = false)\n\t\tend,\n\tnormC = norminf)\n\nprobpo = PeriodicOrbitOCollProblem(200, 2; N = 1, jacobian = BK.AutoDiffDense())\nbr_pocoll = continuation(\n\tbr, 2, opts_po_cont,\n\tprobpo;\n\talg = PALC(tangent = Bordered()),\n\t# regular continuation options\n\tverbosity = 2,\tplot = true,\n\targs_po...,\n\tampfactor = 1/0.467829783456199 * 0.1,\n\tδp = 0.01,\n\tcallback_newton = BK.cbMaxNorm(10.0),\n\t)","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"which gives","category":"page"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"(Image: )","category":"page"},{"location":"tutorials/dde/Humphries/#References","page":"Humphries model (codim 2, periodic orbit)","title":"References","text":"","category":"section"},{"location":"tutorials/dde/Humphries/","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"[Hum]: Humphries et al. (2012), Dynamics of a delay differential equation with multiple state-dependent delays, Discrete and Continuous Dynamical Systems 32(8) pp. 2701-2727 http://dx.doi.org/10.3934/dcds.2012.32.2701)","category":"page"},{"location":"detectionBifurcation/#Detection-of-bifurcation-points","page":"Bifurcation detection (codim 1)","title":"Detection of bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The bifurcations are detected during a call to br = continuation(prob, alg, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"contParams.detect_bifurcation = 2","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The bifurcation points are located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The eigenvalue λ is declared unstable if real(λ) > contParams.tol_stability. The located bifurcation points are then returned in br.specialpoint. ","category":"page"},{"location":"detectionBifurcation/#Precise-detection-of-bifurcation-points-using-Bisection","page":"Bifurcation detection (codim 1)","title":"Precise detection of bifurcation points using Bisection","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"Note that the bifurcation points detected when detect_bifurcation = 2 can be rather crude  localization of the true bifurcation points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) bifurcation has been detected. Hence, we only have a rough idea of where the bifurcation is located, unless your dsmax is very small... This can be improved as follows.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"If you choose detect_bifurcation = 3, a bisection algorithm is used to locate the bifurcation points more precisely. It means that we recursively track down the change in stability. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"n_inversion: number of sign inversions in the bisection algorithm\nmax_bisection_steps maximum number of bisection steps\ntol_bisection_eigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"If this is still not enough, you can use a Newton solver to locate them very precisely. See Fold / Hopf Continuation.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"tip: Bisection mode\nDuring the bisection, the eigensolvers are called like eil(J, nev; bisection = true) in order to be able to adapt the solver precision.","category":"page"},{"location":"detectionBifurcation/#Large-scale-computations","page":"Bifurcation detection (codim 1)","title":"Large scale computations","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"[1]: In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"page"},{"location":"detectionBifurcation/#List-of-detected-bifurcation-points","page":"Bifurcation detection (codim 1)","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"Bifurcation index used\nFold fold\nHopf hopf\nBifurcation point (single eigenvalue stability change, Fold or branch point) bp","category":"page"},{"location":"detectionBifurcation/#Eigensolver","page":"Bifurcation detection (codim 1)","title":"Eigensolver","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where NewtonOptions is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"page"},{"location":"detectionBifurcation/#Generic-bifurcation","page":"Bifurcation detection (codim 1)","title":"Generic bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. ","category":"page"},{"location":"detectionBifurcation/#Fold-bifurcation","page":"Bifurcation detection (codim 1)","title":"Fold bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detect_fold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.foldpoint allowing for later refinement using the function newtonFold.","category":"page"},{"location":"detectionBifurcation/#Hopf-bifurcation","page":"Bifurcation detection (codim 1)","title":"Hopf bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (codim 1)","title":"Bifurcation detection (codim 1)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. When a Hopf point is detected, a point is added to br.specialpoint allowing for later refinement using the function newton_hopf.","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/#Hutchinson-with-Diffusion","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"Pages = [\"HutchinsonDiff.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"Consider the Hutchinson equation with diffusion","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"beginaligned\n fracpartial u(t x)partial t=d fracpartial^2 u(t x)partial x^2-a u(t-1 x)1+u(t x) quad t0 x in(0 pi) \n fracpartial u(t x)partial x=0 x=0 pi\nendaligned","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"where a0 d0. ","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/#Problem-discretization","page":"Hutchinson with Diffusion","title":"Problem discretization","text":"","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"We start by discretizing the above PDE based on finite differences.","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"using Revise, DDEBifurcationKit, Plots, SparseArrays\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction Hutchinson(u, ud, p)\n   (; a, d, Δ) = p\n   d .* (Δ * u) .- a .* ud[1] .* (1 .+ u)\nend\n\ndelaysF(par) = [1.]\nnothing #hide","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/#Bifurcation-analysis","page":"Hutchinson with Diffusion","title":"Bifurcation analysis","text":"","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"We can now instantiate the model","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"# discretisation\nNx = 200; Lx = pi/2;\nX = -Lx .+ 2Lx/Nx*(0:Nx-1) |> collect\nh = 2Lx/Nx\nΔ = spdiagm(0 => -2ones(Nx), 1 => ones(Nx-1), -1 => ones(Nx-1) ) / h^2; Δ[1,1]=Δ[end,end]=-1/h^2\nnothing #hide","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"We are now ready to compute the bifurcation of the trivial (constant in space) solution:","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"# bifurcation problem\npars = (a = 0.5, d = 1, τ = 1.0, Δ = Δ, N = Nx)\nx0 = zeros(Nx)\n\nprob = ConstantDDEBifProblem(Hutchinson, delaysF, x0, pars, (@optic _.a))\n\noptn = NewtonPar(eigsolver = DDE_DefaultEig())\nopts = ContinuationPar(p_max = 10., p_min = 0., newton_options = optn, ds = 0.01, detect_bifurcation = 3, nev = 5, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob, PALC(), opts; verbosity = 0, plot = false, normC = norminf)\nbr","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"We note that the first Hopf point is close to the theoretical value a=fracpi 2. This can be improved by increasing opts.n_inversion.","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"We can now plot the branch","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"scene = plot(br)","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/#Performance-improvements","page":"Hutchinson with Diffusion","title":"Performance improvements","text":"","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"The previous implementation being simple, it leaves a lot performance on the table. For example, the jacobian is dense because it is computed with automatic differentiation without sparsity detection. ","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"We show how to specify the jacobian and speed up the code a lot.","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"# analytical jacobian\nfunction JacHutchinson(u, p)\n   (;a, d, Δ) = p\n   # we compute the jacobian at the steady state\n   J0 = d * Δ .- a .* Diagonal(u)\n   J1 = -a .* Diagonal(1 .+ u)\n   return J0, [J1]\nend\n\nprob2 = ConstantDDEBifProblem(Hutchinson, delaysF, x0, pars, (@optic _.a); J = JacHutchinson)\n\noptn = NewtonPar(eigsolver = DDE_DefaultEig())\nopts = ContinuationPar(p_max = 10., p_min = 0., newton_options = optn, ds = 0.01, detect_bifurcation = 3, nev = 5, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob2, PALC(), opts; verbosity = 1, plot = true, normC = norminf)\nbr","category":"page"},{"location":"tutorials/dde/HutchinsonDiff/#References","page":"Hutchinson with Diffusion","title":"References","text":"","category":"section"},{"location":"tutorials/dde/neuron/#Neuron-model-(codim-2,-periodic-orbits)","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"","category":"section"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"Pages = [\"neuron.md\"]\nDepth = 3","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"Consider the neuron model","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"leftbeginarrayl\ndotx_1(t)=-kappa x_1(t)+beta tanh left(x_1left(t-tau_sright)right)+a_12 tanh left(x_2left(t-tau_2right)right) \ndotx_2(t)=-kappa x_2(t)+beta tanh left(x_2left(t-tau_sright)right)+a_21 tanh left(x_1left(t-tau_1right)right)\nendarrayright","category":"page"},{"location":"tutorials/dde/neuron/#Continuation-and-codim-1-bifurcations","page":"Neuron model (codim 2, periodic orbits)","title":"Continuation and codim 1 bifurcations","text":"","category":"section"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"We first instantiate the model","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"using Revise, DDEBifurcationKit, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction neuronVF(x, xd, p)\n   (; κ, β, a12, a21, τs, τ1, τ2) = p\n   [\n      -κ * x[1] + β * tanh(xd[3][1]) + a12 * tanh(xd[2][2]),\n      -κ * x[2] + β * tanh(xd[3][2]) + a21 * tanh(xd[1][1])\n   ]\nend\n\ndelaysF(par) = [par.τ1, par.τ2, par.τs]\n\npars = (κ = 0.5, β = -1, a12 = 1, a21 = 0.5, τ1 = 0.2, τ2 = 0.2, τs = 1.5)\nx0 = [0.01, 0.001]\n\nprob = ConstantDDEBifProblem(neuronVF, delaysF, x0, pars, (@optic _.τs))\n\noptn = NewtonPar(eigsolver = DDE_DefaultEig(maxit=200))\nopts = ContinuationPar(p_max = 13., p_min = 0., newton_options = optn, ds = -0.01, detect_bifurcation = 3, nev = 5, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob, PALC(), opts; verbosity = 0, plot = true, bothside = true, normC = norminf)","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"We then plot the branch","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"scene = plot(br)","category":"page"},{"location":"tutorials/dde/neuron/#Normal-forms-computation","page":"Neuron model (codim 2, periodic orbits)","title":"Normal forms computation","text":"","category":"section"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"As in BifurcationKit.jl, it is straightforward to compute the normal forms.","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"hopfpt = BK.get_normal_form(br, 2)","category":"page"},{"location":"tutorials/dde/neuron/#Continuation-of-Hopf-points","page":"Neuron model (codim 2, periodic orbits)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"We follow the Hopf points in the parameter plane (a_21tau_s). We tell the solver to consider br.specialpoint[3] and continue it.","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"# continuation of the first Hopf point\nbrhopf = continuation(br, 3, (@optic _.a21),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.04, max_steps = 230, p_max = 15., p_min = -1.,ds = -0.02);\n         detect_codim2_bifurcation = 2,\n         # bothside = true,\n         start_with_eigen = true)\n\n# continuation of the second Hopf point\nbrhopf2 = continuation(br, 2, (@optic _.a21),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.1, max_steps = 56, p_max = 15., p_min = -1.,ds = -0.01, n_inversion = 4);\n         detect_codim2_bifurcation = 2,\n         start_with_eigen = true,\n         bothside=true)\n\nscene = plot(brhopf, brhopf2, legend = :top)","category":"page"},{"location":"tutorials/dde/neuron/#Branch-of-periodic-orbits","page":"Neuron model (codim 2, periodic orbits)","title":"Branch of periodic orbits","text":"","category":"section"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"We change the continuation parameter and study the bifurcations as function of a_21.","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"prob2 = ConstantDDEBifProblem(neuronVF, delaysF, x0, pars, (@optic _.a21))\nbr2 = BK.continuation(prob2, PALC(), ContinuationPar(opts, ds = 0.1, p_max = 3., n_inversion = 4); verbosity = 0, plot = false, normC = norminf)","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"We then compute the branch of periodic orbits from the Hopf bifurcation points using orthogonal collocation.","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.1, ds= -0.0001, dsmin = 1e-4, p_max = 10., p_min=-0., max_steps = 120, detect_bifurcation = 0, save_sol_every_step=1)\n@reset opts_po_cont.newton_options.tol = 1e-8\n@reset opts_po_cont.newton_options.verbose = false\n\n# arguments for periodic orbits\nargs_po = (\trecord_from_solution = (x, p; k...) -> begin\n\t\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\t\treturn (max = maximum(xtt[1,:]),\n\t\t\t\t\tmin = minimum(xtt[1,:]),\n\t\t\t\t\tperiod = getperiod(p.prob, x, nothing))\n\t\tend,\n\t\tplot_solution = (x, p; k...) -> begin\n\t\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\t\tplot!(xtt.t, xtt[1,:]; label = \"V1\", k...)\n\t\t\tplot!(xtt.t, xtt[2,:]; label = \"V2\", k...)\n\t\t\tplot!(br2; subplot = 1, putspecialptlegend = false)\n\t\t\tend,\n\t\tnormC = norminf)\n\nprobpo = PeriodicOrbitOCollProblem(60, 4; N = 2, jacobian = BK.AutoDiffDense())\nbr_pocoll = @time continuation(\n\tbr2, 1, opts_po_cont,\n\tprobpo;\n\tverbosity = 0,\tplot = false,\n\targs_po...,\n\tδp = 0.003,\n\tnormC = norminf,\n\t)\nscene = plot(br2, br_pocoll)","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"We can plot the periodic orbit as they approach the homoclinic point.","category":"page"},{"location":"tutorials/dde/neuron/","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"scene = plot(layout = 2)\nfor ii = 1:10:110\n\tsolpo = BK.get_periodic_orbit(br_pocoll.γ.prob.prob, br_pocoll.sol[ii].x, nothing)\n\tplot!(scene, solpo.t ./ solpo.t[end], solpo.u[1,:], label = \"\", subplot = 1)\nend\nxlabel!(scene, \"t / period\", subplot = 1)\nplot!(scene, br_pocoll, vars = (:param, :period), subplot = 2, xlims=(2.2,2.4))\nscene","category":"page"},{"location":"tutorials/dde/neuron/#References","page":"Neuron model (codim 2, periodic orbits)","title":"References","text":"","category":"section"},{"location":"BifProblem/#Bifurcation-Problem","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"","category":"section"},{"location":"BifProblem/#Constant-delays-(DDE)","page":"Bifurcation Problem","title":"Constant delays (DDE)","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"Consider the system of delay differential equations with constant delays (DDEs)","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"fracmathrmdmathrmd t x(t)=mathbf Fleft(x(t) xleft(t-tau_1right) ldots xleft(t-tau_mright) pright)","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"where the delays tau_i0 are constant and p is a set of parameters. In order to specify this, we need to provide the vector field and the delays. The delays are provided using a delay function which must return an AbstractVecor","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"function mydelays(pars)\n\t[1, pars.tau1]\nend","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"where pars are some user defined variables. The vector field is then specified as follows","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"function myF(x, xd, pars)\n\t[\n\t\tx[1] + xd[2][1]^2,\n\t\tx[2] + xd[3][2]^2,\n\t]\nend","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"where xd is a vector holding [x(t-d[1]), x(t-d[2])] where d = mydelays(pars). Some simple examples can be found in the tutorials.","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"The structure ConstantDDEBifProblem encapsulates the bifurcation problem.","category":"page"},{"location":"BifProblem/#State-dependent-delays-(SD-DDE)","page":"Bifurcation Problem","title":"State-dependent delays (SD-DDE)","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"Consider the system of delay differential equations with state-dependent delays.","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"fracmathrmdmathrmd t x(t)=mathbf Fleft(x(t) xleft(t-tau_1(x(t))right) ldots xleft(t-tau_m(x(t))right) pright)","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"where the delays tau_i0 are functions of x(t) and p is a set of parameters. The only difference with the previous case is the specification of the delay function which now depends on x","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"function mydelays(x, pars)\n\t[\n\t\t1 + x[1]^2,\n\t\t2 + x[2]^2\n\t]\nend","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"The structure SDDDEBifProblem encapsulates the bifurcation problem.","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"A more elaborate problem would be to allow tau_i to depend on the history of x(theta+t) for thetain-tau_max0 and not just on the current value of x(t). This is not implemented yet.","category":"page"},{"location":"periodicOrbitCollocation/#Periodic-orbits-based-on-orthogonal-collocation","page":"Collocation","title":"Periodic orbits based on orthogonal collocation","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We compute Ntst time slices of a periodic orbit using orthogonal collocation. This is implemented in the structure BifurcationKit.PeriodicOrbitOCollProblem.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"warning: Large scale\nThe current implementation is not yet optimized for large scale problems. This will be improved in the future.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"warning: Floquet coefficients\nThe current implementation does not yet allow for computing stability of periodic orbits. This will be improved in the future.  ","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The general method is explained in BifurcationKit.jl.","category":"page"},{"location":"#DDEBifurcationKit.jl","page":"Home","title":"DDEBifurcationKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package aims at performing automatic bifurcation analysis of possibly large dimensional equations delay differential equations (DDE) by taking advantage of iterative methods, dense / sparse formulation and specific hardwares (e.g. GPU).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It builds upon BifurcationKit.jl with version > 0.2 to perform continuation and numerical bifurcation analysis.","category":"page"},{"location":"#Installation","page":"Home","title":"📦 Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Assuming that you already have Julia correctly installed, it suffices to import DDEBifurcationKit.jl in the standard way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"https://github.com/bifurcationkit/DDEBifurcationKit.jl\")","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"📚 Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package for your work, we ask that you cite the following paper!! Open source development strongly depends on this. It is referenced on HAL-Inria with bibtex entry CITATION.bib.","category":"page"},{"location":"#Other-softwares","page":"Home","title":"🧑‍💻 Other softwares","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several good softwares already available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For continuation in small dimension, most softwares are listed on DSWeb. One can mention the widely used DDE-BIFTOOL, Knut. All these are very reliable and some address high codimension bifurcations.\nFor large scale problems, there is very little.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia, the present package seems to be the only one.","category":"page"},{"location":"#A-word-on-performance","page":"Home","title":"A word on performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The examples which follow have not all been written with the goal of performance but rather simplicity (for now).","category":"page"},{"location":"#Main-features","page":"Home","title":"Main features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Newton-Krylov solver with generic linear / eigen preconditioned solver. Idem for the arc-length continuation.\nNewton-Krylov solver with nonlinear deflation and preconditioner. It can be used for branch switching for example.\nContinuation written as an iterator\nMonitoring user functions along curves computed by continuation, see events.\nContinuation methods: PALC, Moore-Penrose, etc. See methods.\nBifurcation points are located using a bisection algorithm\ndetection of Branch, Fold, Hopf bifurcation point of stationary solutions and computation of their normal form.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<ul> \n<li><del>Automatic branch switching at branch points (whatever the dimension of the kernel)</del></li></ul>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automatic branch switching at simple Hopf points to periodic orbits\nAutomatic bifurcation diagram computation of equilibria\nFold / Hopf continuation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<ul> \n<li>detection all codim 2 bifurcations of equilibria and <del>computation of the normal forms of Bogdanov-Takens, Bautin and Cusp</del></li>\n<li><del>Branching from Bogdanov-Takens points to Fold / Hopf curve</del></li>\n<li>Periodic orbit computation and continuation using <del>Shooting, Finite Differences or </del>Orthogonal Collocation.</li>\n<li><del>detection of Branch, Fold, Neimark-Sacker, Period Doubling bifurcation point of periodic orbits.</del></li>\n<li><del>Continuation of Fold of periodic orbits</del></li>\n</ul>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Custom state means, we can use something else than AbstractArray, for example your own struct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type of delay: Constant (C), state-dependent (SD), nested (N)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features delay type Matrix Free Custom state Tutorial GPU\n(Deflated) Krylov-Newton C/SD Yes Yes  \nContinuation PALC (Natural, Secant, Tangent, Polynomial) C/SD    \nBifurcation / Fold / Hopf point detection C/SD Y   \nFold Point continuation C/SD Y   \nHopf Point continuation C/SD  AbstractArray  \n~~Bogdanov-Takens Point newton~~ C/SD Y AbstractArray  \nBranch point / Fold / Hopf normal form C/SD Y   \nBranch switching at Branch / Hopf points C/SD Y AbstractArray  \n<span style=\"color:red\">Automatic bifurcation diagram computation of equilibria</span> C/SD Y AbstractArray  \n~~Periodic Orbit (Trapezoid) Newton / continuation~~   AbstractVector  \nPeriodic Orbit (Collocation) Newton / continuation C/SD  AbstractVector  \n~~Periodic Orbit (Parallel Poincaré / Standard Shooting) Newton / continuation~~   AbstractArray  \n~~Fold, Neimark-Sacker, Period doubling detection~~   AbstractVector  \n~~Continuation of Fold of periodic orbits~~   AbstractVector  \nBogdanov-Takens / Bautin / Cusp / Zero-Hopf / Hopf-Hopf point detection C/SD Y   \n~~Bogdanov-Takens / Bautin / Cusp / Zero-Hopf / Hopf-Hopf normal forms~~  Y   \n~~Branching from Bogdanov-Takens points to Fold / Hopf curve~~   AbstractVector  ","category":"page"},{"location":"#Requested-methods-for-Custom-State","page":"Home","title":"Requested methods for Custom State","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Needless to say, if you use regular arrays, you don't need to worry about what follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We make the same requirements as KrylovKit.jl. Hence, we refer to its docs for more information. We additionally require the following methods to be available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base.length(x): it is used in the constraint equation of the pseudo arclength continuation method (see continuation for more details). If length is not available for your \"vector\", define it length(x) = 1 and adjust tuning the parameter theta in ContinuationPar.\nBase.copyto!(dest, in) this is required to reduce the allocations by avoiding too many copies\nBase.eltype must be extended to your vector type. It is mainly used for branching.","category":"page"},{"location":"#Citations","page":"Home","title":"Citations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The papers citing this work are collected on google scholar.","category":"page"}]
}
