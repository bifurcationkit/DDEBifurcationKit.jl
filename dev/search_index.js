var documenterSearchIndex = {"docs":
[{"location":"simplebp/#Simple-bifurcation-branch-point","page":"Simple branch point","title":"Simple bifurcation branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295\n\nA simple branch point (x_0p_0) for the problem F(xp)=0 satisfies dim ker dF(x_0p_0) = 1. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a scalar polynomial (delta p equiv p-p_0): \n\nadelta p + zleft(b_1delta p + fracb_22z + fracb_36z^2right) = 0 tagE\n\nwhose solutions give access to all solutions in a neighborhood of (xp).\n\nMore precisely, if ker dF(x_0p_0) = mathbb Rzeta, one can show that x_0+zzeta is close to a solution on a new branch, thus satisfying F(x_0+zzetap_0+delta p)approx 0.\n\nIn the above scalar equation,\n\nif aneq 0, this is a Saddle-Node bifurcation\nif a=0b_2neq 0, the bifurcation point is a Transcritical one where the bifurcated branch exists on each side of p.\nif a=0b_2=0 b_3neq 0, the bifurcation point is a Pitchfork one where the bifurcated branch only exists on one side of p. If it exists at smaller values then p, this is a subcritical Pitchfork bifurcation. In the other case, this is a supercritical Pitchfork bifurcation.","category":"section"},{"location":"simplebp/#Normal-form-computation","page":"Simple branch point","title":"Normal form computation","text":"The reduced equation (E) can be automatically computed as follows\n\nget_normal_form(br::ContResult, ind_bif::Int ;\n\tverbose = false, Î¶s = nothing, lens = br.param_lens)\n\nwhere prob is the bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns the following:\n\nmutable struct SimpleBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvector(s)\"\n\tÎ¶::Tevr\n\n\t\"Left eigenvector(s)\"\n\tÎ¶star::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend\n\ninfo: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"section"},{"location":"eigensolver/#Eigen-solvers-(Eig)","page":"Eigen Solvers","title":"Eigen solvers (Eig)","text":"See also Eigen solvers for more information, for example on how to implement your own.","category":"section"},{"location":"eigensolver/#List-of-implemented-eigen-solvers","page":"Eigen Solvers","title":"List of implemented eigen solvers","text":"Default DDE_DefaultEig eigensolver for DDE. You can create it via eig = DDE_DefaultEig(). It is based on the package NonlinearEigenproblems.jl.","category":"section"},{"location":"periodicOrbit/#Periodic-orbits-computation","page":"Introduction","title":"Periodic orbits computation","text":"Consider the DDE problem written\n\nfracdudt=F(u(t) u_tp)tagE\n\nA periodic solution u^* with period T satisfies u^*(t+T)=u^*(t) for all time t.\n\nWe provide 1 method for computing periodic orbits (PO):\n\none (Collocation) based on orthogonal collocation to discretize the above problem (E),","category":"section"},{"location":"periodicOrbit/#Important-notes","page":"Introduction","title":"Important notes","text":"We regroup here some important notes which are valid for all methods above. ","category":"section"},{"location":"periodicOrbit/#1.-Finaliser","page":"Introduction","title":"1. Finaliser","text":"If you pass a finalize function to continuation, the following occurs:\n\nIf the newton solve was successfull, we update the phase condition every update_section_every_step\nwe call the user defined finalizer finalize.","category":"section"},{"location":"tutorials/dde/neuronV2/#(Another)-Neuron-model-(codim-2,-periodic-orbits)","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"(Another) Neuron model (codim 2, periodic orbits)","text":"Pages = [\"neuronV2.md\"]\nDepth = 3\n\nConsider the neuron model\n\nbeginaligned\n dotx_1(t)=-x_1(t)-a gleft(b x_1left(t-tau_1right)right)+c gleft(d x_2left(t-tau_2right)right) \n dotx_2(t)=-x_2(t)-a gleft(b x_2left(t-tau_1right)right)+c gleft(d x_1left(t-tau_2right)right)\nendaligned\n\nwhere g(z)=tanh (z-1)+tanh (1) cosh (1)^2. ","category":"section"},{"location":"tutorials/dde/neuronV2/#Continuation-and-codim-1-bifurcations","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Continuation and codim 1 bifurcations","text":"We first instantiate the model\n\nusing Revise, DDEBifurcationKit, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\ng(z) = (tanh(z âˆ’ 1) + tanh(1)) * cosh(1)^2\nfunction neuron2VF(x, xd, p)\n   (; a,b,c,d) = p\n   [\n      -x[1] - a * g(b*xd[1][1]) + c * g(d*xd[2][2]),\n      -x[2] - a * g(b*xd[1][2]) + c * g(d*xd[2][1])\n   ]\nend\n\nfunction delaysF(par)\n   [par.Ï„1, par.Ï„2]\nend\n\npars = (a = 0.25, b = 2., c = 15/29, d = 1.2, Ï„1 = 12.7, Ï„2 = 20.2)\nx0 = [0.01, 0.001]\n\nprob = ConstantDDEBifProblem(neuron2VF, delaysF, x0, pars, (@optic _.a))\n\noptn = NewtonPar(verbose = false, eigsolver = DDE_DefaultEig(maxit=100))\nopts = ContinuationPar(p_max = 1., p_min = 0., newton_options = optn, ds = 0.01, detect_bifurcation = 3, nev = 9, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob, PALC(tangent=Bordered()), opts)\n\nWe then plot the branch\n\nscene = plot(br)","category":"section"},{"location":"tutorials/dde/neuronV2/#Normal-forms-computation","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Normal forms computation","text":"As in BifurcationKit.jl, it is straightforward to compute the normal forms.\n\nhopfpt = BK.get_normal_form(br, 2)","category":"section"},{"location":"tutorials/dde/neuronV2/#Continuation-of-Hopf-points","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Continuation of Hopf points","text":"We follow the Hopf points in the parameter plane (ac). We tell the solver to consider br.specialpoint[1] and continue it.\n\n# continuation of the first Hopf point\nbrhopf = continuation(br, 1, (@optic _.c),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.01, max_steps = 100, p_max = 1.1, p_min = -0.1,ds = 0.01, n_inversion = 2);\n         verbosity = 0,\n         detect_codim2_bifurcation = 2,\n         bothside = true,\n         start_with_eigen = true)\n\nbrhopf2 = continuation(br, 2, (@optic _.c),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.01, max_steps = 100, p_max = 1.1, p_min = -0.1,ds = -0.01);\n         verbosity = 0,\n         detect_codim2_bifurcation = 2,\n         bothside = true,\n         start_with_eigen = true)\n\nscene = plot(brhopf, vars = (:a, :c), xlims = (0,0.7), ylims = (0, 1))\nplot!(scene, brhopf2, vars = (:a, :c), xlims = (-0,0.7), ylims = (-0.1, 1))\nscene","category":"section"},{"location":"tutorials/dde/neuronV2/#Continuation-of-Fold-points","page":"(Another) Neuron model (codim 2, periodic orbits)","title":"Continuation of Fold points","text":"We follow the Fold points in the parameter plane (a c). We tell the solver to consider br2.specialpoint[3] and continue it.\n\nprob2 = ConstantDDEBifProblem(neuron2VF, delaysF, x0, (pars..., a = 0.12), (@optic _.c))\nbr2 = continuation(prob2, PALC(), ContinuationPar(opts, p_max = 1.22);)\n\n\n# change tolerance for avoiding error computation of the EV\nopts_fold = br.contparams\n@reset opts_fold.newton_options.eigsolver.Ïƒ = 1e-7\n\nbrfold = continuation(br2, 3, (@optic _.a),\n         ContinuationPar(opts_fold; detect_bifurcation = 1, dsmax = 0.01, max_steps = 70, p_max = 0.6, p_min = -0.6,ds = -0.01, n_inversion = 2, tol_stability = 1e-6);\n         verbosity = 1, plot = true,\n         detect_codim2_bifurcation = 2,\n         update_minaug_every_step = 1,\n         bothside = false,\n         start_with_eigen = true)\n\nscene = plot(brfold, vars = (:a, :c), branchlabel = \"Fold\")\nplot!(scene, brhopf, vars = (:a, :c), branchlabel = \"Hopf\")\nplot!(scene, brhopf2, vars = (:a, :c), branchlabel = \"Hopf\")\nscene","category":"section"},{"location":"codim2Continuation/#Fold-/-Hopf-Continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation","text":"In this page, we explain how to perform continuation of Fold / Hopf points and detect the associated bifurcations.","category":"section"},{"location":"codim2Continuation/#List-of-detected-codim-2-bifurcation-points","page":"Fold / Hopf Continuation (codim 2)","title":"List of detected codim 2 bifurcation points","text":"Bifurcation symbol used\nBogdanov-Takens bt\nBautin gh\nCusp cusp\nZero-Hopf zh\nHopf-Hopf hh\n\nIn a nutshell, all you have to do (see below) is to call continuation(br, ind_bif, lens2) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options.","category":"section"},{"location":"codim2Continuation/#Fold-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Fold continuation","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities. See docs in BifurcationKit for more information.","category":"section"},{"location":"codim2Continuation/#Detection-of-codim-2-bifurcation-points","page":"Fold / Hopf Continuation (codim 2)","title":"Detection of codim 2 bifurcation points","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation.\n\nthe detection of Cusp (Cusp) is done by the detection of Fold bifurcation points along the curve of Folds by monitoring the parameter component of the tangent.\nthe detection of Bogdanov-Takens (BT) is performed using the test function[Bindel] psi_BT(p) = langle w(p)v(p)rangle\nthe detection of Zero-Hopf (ZH) is performed by monitoring the number of eigenvalues lambda such that Relambda  minlimits_nuinSigma(dF)Renu and Imlambda  epsilon where epsilon is the Newton tolerance.","category":"section"},{"location":"codim2Continuation/#Hopf-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Hopf continuation","text":"The continuation of Fold bifurcation points is based on solving the extended system for (u^* v omega)\n\nbeginaligned\n 0=mathbf Fleft(u^* u^* pright) \n 0=Deltaleft(u^* p mathrmi omegaright) v \n 0=v^mathrmH v-1\nendaligned\n\nwhere Delta(lambda)cdot v = lambda v - d_1mathbf F(u^*u^* p)cdot v-d_2mathbf F(u^* u^* p)cdot(e^lambdacdotv).","category":"section"},{"location":"codim2Continuation/#Detection-of-codim-2-bifurcation-points-2","page":"Fold / Hopf Continuation (codim 2)","title":"Detection of codim 2 bifurcation points","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation.\n\nthe detection of Bogdanov-Takens (BT) is performed using the test function psi_BT(p) = \tomega\nthe detection of Bautin (GH) is based on the test function psi_GH(p) = Re(l_1(p)) where l_1 is the Lyapunov coefficient defined in Simple Hopf point.\nthe detection of Zero-Hopf (ZH) is performed by monitoring the eigenvalues.\nthe detection of Hopf-Hopf (HH) is performed by monitoring the eigenvalues.\n\nThe continuation of Hopf points is stopped at BT and when omega100epsilon where epsilon is the newton tolerance.","category":"section"},{"location":"codim2Continuation/#Codim-2-continuation","page":"Fold / Hopf Continuation (codim 2)","title":"Codim 2 continuation","text":"To compute the codim 2 curve of Fold / Hopf points, one can call continuation with the following options\n\nwhere the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points.","category":"section"},{"location":"library/#Library","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"section"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/#Eigen-solvers","page":"Library","title":"Eigen solvers","text":"","category":"section"},{"location":"library/#Branch-switching-(branch-point)","page":"Library","title":"Branch switching (branch point)","text":"","category":"section"},{"location":"library/#Branch-switching-(Hopf-point)","page":"Library","title":"Branch switching (Hopf point)","text":"","category":"section"},{"location":"library/#Utils-for-periodic-orbits","page":"Library","title":"Utils for periodic orbits","text":"","category":"section"},{"location":"library/#Misc.","page":"Library","title":"Misc.","text":"","category":"section"},{"location":"library/#BifurcationKit.NewtonPar","page":"Library","title":"BifurcationKit.NewtonPar","text":"struct NewtonPar{T, L<:BifurcationKit.AbstractLinearSolver, E<:AbstractEigenSolver}\n\nReturns a variable containing parameters to affect the newton algorithm when solving F(x) = 0.\n\nArguments (with default values):\n\ntol::Any: absolute tolerance for F(x) Default: 1.0e-12\nmax_iterations::Int64: number of Newton iterations Default: 25\nverbose::Bool: display Newton iterations? Default: false\nlinsolver::BifurcationKit.AbstractLinearSolver: linear solver, must be <: AbstractLinearSolver Default: DefaultLS()\neigsolver::AbstractEigenSolver: eigen solver, must be <: AbstractEigenSolver Default: DefaultEig()\nlinesearch::Bool: Default: false\nÎ±::Any: Default: convert(typeof(tol), 1.0)\nÎ±min::Any: Default: convert(typeof(tol), 0.001)\n\nArguments for line search (Armijo)\n\nlinesearch = false: use line search algorithm (i.e. Newton with Armijo's rule)\nÎ± = 1.0: initial value of Î± (damping) parameter for line search algorithm\nÎ±min  = 0.001: minimal value of the damping alpha\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Accessors.jl to drastically simplify the mutation of different fields. See the tutorials for examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#BifurcationKit.ContinuationPar","page":"Library","title":"BifurcationKit.ContinuationPar","text":"struct ContinuationPar{T, S<:BifurcationKit.AbstractLinearSolver, E<:AbstractEigenSolver}\n\nReturns a variable containing the parameters to affect the continuation algorithm used to solve F(x, p) = 0.\n\nArguments\n\ndsmin, dsmax are the minimum, maximum allowed arc-length value. It controls the density of points in the computed branch of solutions.\nds = 0.01 is the initial arc-length.\np_min, p_max allowed parameter range for p\nmax_steps = 100 maximum number of continuation steps\nnewton_options::NewtonPar: options for the Newton algorithm\nsave_to_file = false: save to file. A name is automatically generated or can be defined in continuation. This requires using JLD2.\nsave_sol_every_step::Int64 = 0 at which continuation steps do we save the current solution\nplot_every_step = 10 at which continuation steps do we plot the current solution\n\nHandling eigen-elements, their computation is triggered by the argument detect_bifurcation (see below)\n\nnev = 3 number of eigenvalues to be computed. It is automatically increased to have at least nev unstable eigenvalues. To be set for proper  bifurcation detection. See Detection of bifurcation points of Equilibria for more information.\nsave_eig_every_step = 1 record eigen vectors every specified steps. Important for memory limited resource, e.g. GPU.\nsave_eigenvectors = true Important for memory limited resource, e.g. GPU.\n\nHandling bifurcation detection\n\ntol_stability = 1e-10 lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits\ndetect_fold = true detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndetect_bifurcation::Int âˆˆ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)\ndsmin_bisection = 1e-16 minimal ds for the bisection algorithm for locating bifurcation points\nn_inversion = 2 number of sign inversions in bisection algorithm\nmax_bisection_steps = 15 maximum number of bisection steps\ntol_bisection_eigenvalue = 1e-16 tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps\n\nHandling ds adaptation (see continuation for more information)\n\na  = 0.5 aggressiveness factor. It is used to adapt ds in order to have a number of newton iterations per continuation step roughly constant. The higher a is, the larger the step size ds is changed at each continuation step.\n\nHandling event detection\n\ndetect_event::Int âˆˆ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are sought during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).\ntol_param_bisection_event = 1e-16 tolerance on parameter to locate event\n\nMisc\n\nÎ· = 150. parameter to estimate tangent at first point with parameter  pâ‚€ + ds / Î·\ndetect_loop [WORK IN PROGRESS] detect loops in the branch and stop the continuation\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Accessors.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#DDEBifurcationKit.ConstantDDEBifProblem","page":"Library","title":"DDEBifurcationKit.ConstantDDEBifProblem","text":"struct ConstantDDEBifProblem{Tvf, Tdf, Tu, Td, Tp, Tl<:Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}, Tplot, Trec, Tgets, TÎ´} <: DDEBifurcationKit.AbstractDDEBifurcationProblem\n\nStructure to hold the bifurcation problem. If don't have parameters, you can pass nothing.\n\nFields\n\nVF::Any: Vector field, typically a BifFunction. For more information, please look at the website https://bifurcationkit.github.io/DDEBifurcationKit.jl/dev/BifProblem\ndelays::Any: function delays. It takes the parameters and return the non-zero delays in an AbstractVector form. Example: delays = par -> [1.]\nu0::Any: Initial guess\ndelays0::Any: initial delays (set internally by the constructor)\nparams::Any: parameters\nlens::Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}: Typically a Accessors.@optic. It specifies which parameter axis among params is used for continuation. For example, if par = (Î± = 1.0, Î² = 1), we can perform continuation w.r.t. Î± by using lens = (@optic _.Î±). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@optic _[1]). For more information, we refer to Accessors.jl.\nplotSolution::Any: user function to plot solutions during continuation. Signature: plotSolution(x, p; kwargs...)\nrecordFromSolution::Any: record_from_solution = (x, p; k...) -> norm(x) function used record a few indicators about the solution. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch (see below). Finally, the first component is used to plot in the continuation curve.\nsave_solution::Any: function to save the full solution on the branch. Some problem are mutable (like periodic orbit functional with adaptive mesh) and this function allows to save the state of the problem along with the solution itself. Signature save_solution(x, p)\nÎ´::Any: delta for Finite differences\n\nMethods\n\ngetu0(pb) calls pb.u0\ngetparams(pb) calls pb.params\ngetlens(pb) calls pb.lens\nsetparam(pb, p0) calls set(pb.params, pb.lens, p0)\nrecord_from_solution(pb) calls pb.record_from_solution\n\nConstructors\n\nConstantDDEBifProblem(F, delays, u0, params, lens; J, Jáµ—, d2F, d3F, kwargs...) and kwargs are the fields above.\n\n\n\n\n\n","category":"type"},{"location":"library/#DDEBifurcationKit.SDDDEBifProblem","page":"Library","title":"DDEBifurcationKit.SDDDEBifProblem","text":"struct SDDDEBifProblem{Tvf, Tdf, Tu, Td, Tp, Tl<:Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}, Tplot, Trec, Tgets, TÎ´} <: DDEBifurcationKit.AbstractDDEBifurcationProblem\n\nStructure to hold the bifurcation problem. If don't have parameters, you can pass nothing.\n\nFields\n\nVF::Any: Vector field, typically a BifFunction. For more information, please look at the website https://bifurcationkit.github.io/DDEBifurcationKit.jl/dev/BifProblem\ndelays::Any: function delays. It takes the parameters and the state and return the non-zero delays in an AsbtractVector form. Example: delays = (par, u) -> [1. + u[1]^2]\nu0::Any: Initial guess\ndelays0::Any: initial delays (set internally by the constructor)\nparams::Any: parameters\nlens::Union{typeof(identity), Nothing, IndexLens, PropertyLens, ComposedFunction}: see ConstantDDEBifProblem for more information.\nplotSolution::Any: user function to plot solutions during continuation. Signature: plotSolution(x, p; kwargs...)\nrecordFromSolution::Any: record_from_solution = (x, p; k...) -> norm(x) function used record a few indicators about the solution. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch (see below). Finally, the first component is used to plot in the continuation curve.\nsave_solution::Any: function to save the full solution on the branch. Some problem are mutable (like periodic orbit functional with adaptive mesh) and this function allows to save the state of the problem along with the solution itself. Signature save_solution(x, p)\nÎ´::Any: delta for Finite differences\n\nMethods\n\ngetu0(pb) calls pb.u0\ngetparams(pb) calls pb.params\ngetlens(pb) calls pb.lens\nsetparam(pb, p0) calls set(pb.params, pb.lens, p0)\nrecord_from_solution(pb) calls pb.record_from_solution\n\nConstructors\n\nSDDDEBifProblem(F, delays, u0, params, lens; J, Jáµ—, d2F, d3F, kwargs...) and kwargs are the fields above.\n\n\n\n\n\n","category":"type"},{"location":"library/#DDEBifurcationKit.DDE_DefaultEig","page":"Library","title":"DDEBifurcationKit.DDE_DefaultEig","text":"mutable struct DDE_DefaultEig{T, Tw, Tv} <: DDEBifurcationKit.AbstractDDEEigenSolver\n\nDefault eigen solver for DDEBifurcationKit based on the julia package NonlinearEigenproblems.jl. ore precisely, we rely on NonlinearEigenproblems.iar_chebyshev for the computation of eigenvalues.\n\nFields\n\nmaxit::Int64: Default: 100\nwhich::Any: Default: real\nÏƒ::Any: Default: 0.0\nÎ³::Any: Default: 1.0\ntol::Any: Default: 1.0e-10\nlogger::Int64: Default: 0\ncheck_error_every::Int64: Default: 1\nv::Any: Default: nothing\n\nConstructors\n\nDDE_DefaultEig(; kwargs...) and kwargs are the fields above.\n\n\n\n\n\n","category":"type"},{"location":"library/#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}","page":"Library","title":"BifurcationKit.continuation","text":"continuation(\n    br::BifurcationKit.AbstractBranchResult,\n    ind_bif::Int64,\n    _contParams::ContinuationPar,\n    pbPO::BifurcationKit.AbstractPeriodicOrbitProblem;\n    bif_prob,\n    detailed,\n    use_normal_form,\n    autodiff_nf,\n    nev,\n    kwargs...\n) -> Branch\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points of a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprobPO problem used to specify the way toc compute the periodic orbit. It can be PeriodicOrbitTrapProblem, PeriodicOrbitOCollProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nalg = br.alg continuation algorithm\nÎ´p used to specify the guess for the parameter on the bifurcated branch which otherwise defaults to contParams.ds. This allows to use an initial step larger than contParams.dsmax.\nampfactor = 1 multiplicative factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nuse_normal_form = true whether to use the normal form in order to compute the predictor. When false, ampfactor and Î´p are used to make a predictor based on the bifurcating eigenvector. Setting use_normal_form = false can be useful when computing the normal form is not possible for example when higher order derivatives are not available.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nnev number of eigenvalues to be computed to get the right eigenvector\nautodiff_nf = true whether to use autodiff in get_normal_form. This can be used in case automatic differentiation is not working as intended.\nall kwargs from continuation\n\nA modified version of prob is passed to plot_solution and finalise_solution.\n\nnote: Linear solver\nYou have to be careful about the options contParams.newton_options.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\n\n\n\n\n","category":"method"},{"location":"library/#BifurcationKit.getperiod","page":"Library","title":"BifurcationKit.getperiod","text":"getperiod(\n    ::BifurcationKit.AbstractPeriodicOrbitProblem,\n    x\n) -> Any\ngetperiod(\n    ::BifurcationKit.AbstractPeriodicOrbitProblem,\n    x,\n    par\n) -> Any\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetperiod(prob::PeriodicOrbitTrapProblem, x, p) -> Any\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetperiod(psh::PoincareShootingProblem, x_bar, par) -> Any\n\n\nCompute the period of the periodic orbit associated to x_bar.\n\n\n\n\n\n","category":"function"},{"location":"library/#BifurcationKit.get_normal_form","page":"Library","title":"BifurcationKit.get_normal_form","text":"get_normal_form(\n    prob::BifurcationKit.AbstractBifurcationProblem,\n    br::BifurcationKit.AbstractBranchResult,\n    id_bif::Int64;\n    ...\n) -> Any\nget_normal_form(\n    prob::BifurcationKit.AbstractBifurcationProblem,\n    br::BifurcationKit.AbstractBranchResult,\n    id_bif::Int64,\n    Teigvec::Type{ð’¯eigvec};\n    nev,\n    verbose,\n    lens,\n    detailed,\n    autodiff,\n    scaleÎ¶,\n    Î¶s,\n    Î¶s_ad,\n    bls,\n    bls_adjoint,\n    bls_block,\n    start_with_eigen\n) -> Any\n\n\nCompute the reduced equation / normal form of the bifurcation point located at br.specialpoint[ind_bif].\n\nArguments\n\nprob::AbstractBifurcationProblem\nbr result from a call to continuation\nind_bif index of the bifurcation point in br.specialpoint\n\nOptional arguments\n\nnev number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.\nverbose whether to display information\nÎ¶s list of vectors spanning the kernel of the jacobian at the bifurcation point. Useful for enforcing the kernel basis used for the normal form.\nlens::Lens specify which parameter to take the partial derivative âˆ‚pF\nscaleÎ¶ function to normalize the kernel basis. Indeed, the kernel vectors are normalized using norm, the normal form coefficients can be super small and can imped its analysis. Using scaleÎ¶ = norminf can help sometimes.\nautodiff = true whether to use ForwardDiff for the differentiations. Used for example for Bogdanov-Takens (BT) point.\ndetailed = Val(true) whether to compute only a simplified normal form when only basic information is required. This can be useful is cases the computation is \"long\", for example for a Bogdanov-Takens point.\nbls = MatrixBLS() specify bordered linear solver. Needed to compute the reduced equation Taylor expansion of Branch/BT points. Indeed, it is required to solve Lâ‹…u = rhs where L is the jacobian at the bifurcation point, L is thus singular and we rely on a bordered linear solver to solve this system.\nbls_block = bls specify bordered linear solver when the border has dimension > 1 (1 for bls). (see bls option above).\n\nAvailable method(s)\n\nYou can directly call \n\nget_normal_form(br, ind_bif ; kwargs...)\n\nwhich is a shortcut for get_normal_form(getprob(br), br, ind_bif ; kwargs...).\n\nOnce the normal form nf has been computed, you can call predictor(nf, Î´p) to obtain an estimate of the bifurcating branch.\n\nReferences\n\n[1] Golubitsky, Martin, and David G Schaeffer. Singularities and Groups in Bifurcation Theory. Springer-Verlag, 1985. http://books.google.com/books?id=rrg-AQAAIAAJ.\n\n[2] KielhÃ¶fer, HansjÃ¶rg. Bifurcation Theory: An Introduction with Applications to PDEs. Applied Mathematical Sciences 156. Springer, 2003. https://doi.org/10.1007/978-1-4614-0502-3.\n\n\n\n\n\nget_normal_form(\n    prob::BifurcationKit.AbstractPeriodicOrbitProblem,\n    br::BifurcationKit.AbstractResult{<:BifurcationKit.PeriodicOrbitCont},\n    id_bif::Int64;\n    ...\n) -> Any\nget_normal_form(\n    prob::BifurcationKit.AbstractPeriodicOrbitProblem,\n    br::BifurcationKit.AbstractResult{<:BifurcationKit.PeriodicOrbitCont},\n    id_bif::Int64,\n    Teigvec::Type{ð’¯eigvec};\n    nev,\n    verbose,\n    Î¶s,\n    lens,\n    scaleÎ¶,\n    autodiff,\n    Î´,\n    k...\n) -> Any\n\n\nCompute the normal form (NF) of bifurcations of periodic orbits. We detail the additional keyword arguments specific to periodic orbits.\n\nOptional arguments\n\nprm = true compute the normal form using PoincarÃ© return map (PRM). If false, use the Iooss normal form. \nnev = length(eigenvalsfrombif(br, id_bif)),\nverbose = false,\nÎ¶s = nothing, pass the eigenvectors\nlens = getlens(br),\nTeigvec = _getvectortype(br) type of the eigenvectors (can be useful for GPU)\nscaleÎ¶ = norm, scale the eigenvector\nautodiff = false use autodiff or finite differences in some part of the normal form computation\ndetailed = true whether to compute only a simplified normal form when only basic information is required. This can be useful is cases the computation is long.\nÎ´ = getdelta(prob) delta used for derivatives based on finite differences.\n\nNotes\n\nFor collocation, the default method to compute the NF of Period-doubling and Neimark-Sacker bifurcations is Iooss' one [1].\n\nReferences\n\n[1] Iooss, \"Global Characterization of the Normal Form for a Vector Field near a Closed Orbit.\", 1988\n\n\n\n\n\n","category":"function"},{"location":"nonsimplebp/#Non-simple-branch-point","page":"Non-simple branch point","title":"Non-simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295\n\ntip: Example\nAn example of use of the methods presented here is provided in 2d generalized Bratuâ€“Gelfand problem.    \n\nWe expose our method to study non-simple branch points. Such branch point (x_0p_0) for the problem F(xp)=0 satisfies d=dim ker dF(x_0p_0)  1 and the eigenvalues have zero imaginary part. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a d-dimensional polynomial equation, called the reduced equation.\n\nMore precisely, it is possible to write x = u + v where uin ker dF(x_0p_0) and vapprox 0 belongs to a vector space complement of ker dF(x_0p_0). It can be shown that u solves Phi(udelta p)=0 with Phi(udelta p) = (I-Pi)F(u+psi(udelta p)p_0+delta p) where psi is known implicitly and Pi is the spectral projector on ker dF(x_0p_0). Fortunately, one can compute the Taylor expansion of Phi up to order 3. Computing the bifurcation diagram of this d-dimensional multivariate polynomials can be done using brute force methods.\n\nOnce the zeros of Phi have been located, we can use them as initial guess for continuation but for the original F !!","category":"section"},{"location":"nonsimplebp/#Reduced-equation-computation","page":"Non-simple branch point","title":"Reduced equation computation","text":"The reduced equation (E) can be automatically computed as follows\n\nget_normal_form(br::ContResult, ind_bif::Int ; verbose = false, Î¶s = nothing, lens = br.param_lens)\n\nwhere prob is a bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. It returns a point with all requested information:\n\nmutable struct NdBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvectors\"\n\tÎ¶::Tevr\n\n\t\"Left eigenvectors\"\n\tÎ¶star::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"section"},{"location":"nonsimplebp/#Using-the-Reduced-equation","page":"Non-simple branch point","title":"Using the Reduced equation","text":"Once a branch point has been computed bp = get_normal_form(...), you can do all sort of things. \n\nFor example, quoted from the file test/testNF.jl, you can print the 2d reduced equation as follows:\n\njulia> BifurcationKit.nf(bp2d)\n2-element Array{String,1}:\n \" + (3.23 + 0.0im) * x1 * p + (-0.123 + 0.0im) * x1^3 + (-0.234 + 0.0im) * x1 * x2^2\"\n \" + (-0.456 + 0.0im) * x1^2 * x2 + (3.23 + 0.0im) * x2 * p + (-0.123 + 0.0im) * x2^3\"\n\nYou can evaluate the reduced equation as bp2d(Val(:reducedForm), rand(2), 0.2). This can be used to find all the zeros of the reduced equation by sampling on a grid. \nFinally, given a d-dimensional vector x and a parameter delta p, you can have access to an initial guess u (see above) by calling bp2d(rand(2), 0.1)","category":"section"},{"location":"faq/#FAQ","page":"Frequently Asked Questions","title":"FAQ","text":"See also FAQ of BifurcationKit.jl.","category":"section"},{"location":"branchswitching/#Branch-switching-page","page":"Branch switching","title":"Branch switching","text":"The precise definition of the methods are given in Branch switching (branch point) and Branch switching (Hopf point).\n\nPages = [\"branchswitching.md\"]\nDepth = 3","category":"section"},{"location":"branchswitching/#Branch-switching-from-simple-branch-point-to-equilibria","page":"Branch switching","title":"Branch switching from simple branch point to equilibria","text":"You can perform automatic branch switching by calling continuation with the following options:\n\ncontinuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar; kwargs...)\n\nwhere br is a branch computed after a call to continuation with detection of bifurcation points enabled. This call computes the branch bifurcating from the ind_bifth bifurcation point in br. An example of use is provided in 2d generalized Bratuâ€“Gelfand problem.\n\nSee Branch switching (branch point) precise method definition","category":"section"},{"location":"branchswitching/#Simple-example","page":"Branch switching","title":"Simple example","text":"using BifurcationKit, Plots\n\n# vector field of transcritical bifurcation\nF(x, p) = [x[1] * (p.Î¼ - x[1])]\n\n# parameters of the vector field\npar = (Î¼ = -0.2, )\n\n# problem (automatic differentiation)\nprob = BifurcationProblem(F, [0.1], par, (@optic _.Î¼); record_from_solution = (x, p; k...) -> x[1])\n\n# compute branch of trivial equilibria (=0) and detect a bifurcation point\nopts_br = ContinuationPar(dsmax = 0.05, ds = 0.01, detect_bifurcation = 3, nev = 2)\nbr = continuation(prob, PALC(), opts_br)\n\t\n# perform branch switching on one side of the bifurcation point\nbr1Top = continuation(br, 1, ContinuationPar(opts_br; max_steps = 14) )\n\n# on the other side\nbr1Bottom = continuation(br, 1, ContinuationPar(opts_br; ds = -opts_br.ds, max_steps = 14))\n\nscene = plot(br, br1Top, br1Bottom; branchlabel = [\"br\", \"br1Top\", \"br1Bottom\"], legend = :topleft)","category":"section"},{"location":"branchswitching/#Branch-switching-from-non-simple-branch-point-to-equilibria","page":"Branch switching","title":"Branch switching from non simple branch point to equilibria","text":"We provide an automatic branch switching method in this case. The method is to first compute the reduced equation (see Non-simple branch point) and use it to compute the nearby solutions. These solutions are seeded as initial guess for continuation. Hence, you can perform automatic branch switching by calling continuation with the following options:\n\ncontinuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar; kwargs...)\n\nAn example of use is provided in 2d generalized Bratuâ€“Gelfand problem.\n\nSee Branch switching (branch point) for the precise method definition","category":"section"},{"location":"branchswitching/#Branch-switching-from-Hopf-point-to-periodic-orbits","page":"Branch switching","title":"Branch switching from Hopf point to periodic orbits","text":"In order to compute the bifurcated branch of periodic solutions at a Hopf bifurcation point, you need to choose a method to compute periodic orbits among:\n\nPeriodic orbits based on orthogonal collocation\n\nOnce you have decided which method to use, you use the following call:\n\ncontinuation(br::ContResult, ind_HOPF::Int, _contParams::ContinuationPar,\n\tprob::AbstractPeriodicOrbitProblem ;\n\tÎ´p = nothing, ampfactor = 1, kwargs...)\n\nWe refer to continuation for more information about the arguments. Here, we just say a few words about how we can specify prob::AbstractPeriodicOrbitProblem.\n\nFor Periodic orbits based on orthogonal collocation, you can pass PeriodicOrbitOCollProblem(M, m) where M is the number of times slices in the periodic orbit and m is the degree of the collocation polynomials.","category":"section"},{"location":"simplehopf/#Simple-Hopf-point","page":"Simple Hopf","title":"Simple Hopf point","text":"At a Hopf branch point (x_0p_0) for the problem F(xp)=0, the spectrum of the linear operator dF(x_0p_0) contains two purely imaginary pm iomega omega  0 which are simple. At such point, we can compute the normal form to transform the DDE problem\n\ndot x = mathbfF(x_tp)\n\nin large dimensions to a complex polynomial vector field (delta pequiv p-p_0):\n\ndot z = zleft(a cdotdelta p + iomega + l_1z^2right)quadtext(E)\n\nwhose solutions give access to the solutions of the Cauchy problem in a neighborhood of (xp).\n\ntip: Coefficient $l_1$\nThe coefficient l_1 above is called the Lyapunov coefficient","category":"section"},{"location":"simplehopf/#Normal-form-computation","page":"Simple Hopf","title":"Normal form computation","text":"The normal form (E) is automatically computed as follows\n\nget_normal_form(br::ContResult, ind_bif::Int ;\n\tverbose = false, Î¶s = nothing, lens = br.param_lens)\n\nwhere prob is a bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The above call returns a point with information needed to compute the bifurcated branch.\n\nmutable struct Hopf{Tv, T, TÏ‰, Tevr, Tevl, Tnf} <: BifurcationPoint\n\t\"Hopf point\"\n\tx0::Tv\n\n\t\"Parameter value at the Hopf point\"\n\tp::T\n\n\t\"Frequency of the Hopf point\"\n\tÏ‰::TÏ‰\n\n\t\"Right eigenvector\"\n\tÎ¶::Tevr\n\n\t\"Left eigenvector\"\n\tÎ¶star::Tevl\n\n\t\"Normal form coefficient (a = 0., b = 1 + 1im)\"\n\tnf::Tnf\n\n\t\"Type of Hopf bifurcation\"\n\ttype::Symbol\nend\n\ninfo: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"section"},{"location":"simplehopf/#References","page":"Simple Hopf","title":"References","text":"[Haragus]: Haragus, Mariana, and GÃ©rard Iooss. Local Bifurcations, Center Manifolds, and Normal Forms in Infinite-Dimensional Dynamical Systems. London: Springer London, 2011. https://doi.org/10.1007/978-0-85729-112-7.","category":"section"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/#Constant-delays-examples","page":"Tutorials","title":"Constant delays examples","text":"Pages = [\"dde/neuron.md\",\"dde/neuronV2.md\"]\nDepth = 1","category":"section"},{"location":"tutorials/tutorials/#State-dependent-delays-examples","page":"Tutorials","title":"State dependent delays examples","text":"Pages = [\"dde/Humphries.md\",]\nDepth = 1","category":"section"},{"location":"tutorials/tutorials/#Delayed-PDE-examples","page":"Tutorials","title":"Delayed PDE examples","text":"Pages = [\"dde/HutchinsonDiff.md\"]\nDepth = 1","category":"section"},{"location":"tutorials/dde/Humphries/#Humphries-model-(codim-2,-periodic-orbit)","page":"Humphries model (codim 2, periodic orbit)","title":"Humphries model (codim 2, periodic orbit)","text":"Pages = [\"Humphries.md\"]\nDepth = 3\n\nConsider the model [Hum] as an example of state-dependent delays\n\nx^prime(t)=-gamma x(t)-kappa_1 xleft(t-a_1-c x(t)right)-kappa_2 xleft(t-a_2-c x(t)right)","category":"section"},{"location":"tutorials/dde/Humphries/#Continuation-and-codim-1-bifurcations","page":"Humphries model (codim 2, periodic orbit)","title":"Continuation and codim 1 bifurcations","text":"We first instantiate the model\n\nusing Revise, DDEBifurcationKit, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction humpriesVF(x, xd, p)\n   (;Îº1, Îº2, Î³, a1, a2, c) = p\n   [\n      -Î³ * x[1] - Îº1 * xd[1][1] - Îº2 * xd[2][1]\n   ]\nend\n\nfunction delaysF(x, par)\n   [\n      par.a1 + par.c * x[1],\n      par.a2 + par.c * x[1],\n   ]\nend\n\n\npars = (Îº1=0.,Îº2=2.3,a1=1.3,a2=6,Î³=4.75,c=1.)\nx0 = zeros(1)\n\nprob = SDDDEBifProblem(humpriesVF, delaysF, x0, pars, (@optic _.Îº1))\n\nWe then compute the branch\n\noptn = NewtonPar(verbose = true, eigsolver = DDE_DefaultEig())\nopts = ContinuationPar(p_max = 13., p_min = 0., newton_options = optn, ds = -0.01, detect_bifurcation = 3, nev = 3, )\nbr = continuation(prob, PALC(), opts; verbosity = 0, bothside = true)\n\nand plot it\n\nscene = plot(br)","category":"section"},{"location":"tutorials/dde/Humphries/#Continuation-of-Hopf-point","page":"Humphries model (codim 2, periodic orbit)","title":"Continuation of Hopf point","text":"We follow the Hopf points in the parameter plane (kappa_1kappa_2). We tell the solver to consider br.specialpoint[2] and continue it.\n\nbrhopf = continuation(br, 2, (@optic _.Îº2),\n         ContinuationPar(br.contparams, detect_bifurcation = 2, dsmax = 0.04, max_steps = 230, p_max = 5., p_min = -1.,ds = -0.02);\n         verbosity = 0, plot = false,\n         # we disable detection of Bautin bifurcation as the\n         # Hopf normal form is not implemented for SD-DDE\n         detect_codim2_bifurcation = 0,\n         bothside = true,\n         start_with_eigen = true)\n\nscene = plot(brhopf, vars = (:Îº1, :Îº2))","category":"section"},{"location":"tutorials/dde/Humphries/#Branch-of-periodic-orbits","page":"Humphries model (codim 2, periodic orbit)","title":"Branch of periodic orbits","text":"We compute the branch of periodic orbits from the Hopf bifurcation points using orthogonal collocation. We use a lot of time sections N_tst=200 to have enough precision to resolve the sophisticated branch of periodic solutions especially near the first Fold point around kappa_1approx 10.\n\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.05, ds= 0.001, dsmin = 1e-4, p_max = 12., p_min=-5., max_steps = 3000,\n\tnev = 3, tol_stability = 1e-8, detect_bifurcation = 0, plot_every_step = 20)\n@reset opts_po_cont.newton_options.tol = 1e-9\n@reset opts_po_cont.newton_options.verbose = true\n\n# arguments for periodic orbits\nargs_po = (\trecord_from_solution = (x, p; k...) -> begin\n\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\t_max = maximum(xtt[1,:])\n\t\t_min = minimum(xtt[1,:])\n\t\treturn (amp = _max - _min,\n\t\t\t\tperiod = getperiod(p.prob, x, nothing))\n\tend,\n\tplot_solution = (x, p; k...) -> begin\n\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\tplot!(xtt.t, xtt[1,:]; label = \"x\", k...)\n\t\tplot!(br; subplot = 1, putspecialptlegend = false)\n\t\tend,\n\tnormC = norminf)\n\nprobpo = PeriodicOrbitOCollProblem(200, 2; N = 1, jacobian = BK.AutoDiffDense())\nbr_pocoll = continuation(\n\tbr, 2, opts_po_cont,\n\tprobpo;\n\talg = PALC(tangent = Bordered()),\n\t# regular continuation options\n\tverbosity = 2, plot = true,\n\targs_po...,\n\tampfactor = 1/0.467829783456199 * 0.1,\n\tÎ´p = 0.01,\n\tcallback_newton = BK.cbMaxNorm(10.0),\n\t)\n\nwhich gives\n\n(Image: )","category":"section"},{"location":"tutorials/dde/Humphries/#References","page":"Humphries model (codim 2, periodic orbit)","title":"References","text":"[Hum]: Humphries et al. (2012), Dynamics of a delay differential equation with multiple state-dependent delays, Discrete and Continuous Dynamical Systems 32(8) pp. 2701-2727 http://dx.doi.org/10.3934/dcds.2012.32.2701)","category":"section"},{"location":"detectionBifurcation/#Detection-of-bifurcation-points","page":"Bifurcation detection (codim 1)","title":"Detection of bifurcation points","text":"The bifurcations are detected during a call to br = continuation(prob, alg, contParams::ContinuationPar;kwargs...) by turning on the following flags:\n\ncontParams.detect_bifurcation = 2\n\nThe bifurcation points are located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The eigenvalue Î» is declared unstable if real(Î») > contParams.tol_stability. The located bifurcation points are then returned in br.specialpoint. ","category":"section"},{"location":"detectionBifurcation/#Precise-detection-of-bifurcation-points-using-Bisection","page":"Bifurcation detection (codim 1)","title":"Precise detection of bifurcation points using Bisection","text":"Note that the bifurcation points detected when detect_bifurcation = 2 can be rather crude  localization of the true bifurcation points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) bifurcation has been detected. Hence, we only have a rough idea of where the bifurcation is located, unless your dsmax is very small... This can be improved as follows.\n\nIf you choose detect_bifurcation = 3, a bisection algorithm is used to locate the bifurcation points more precisely. It means that we recursively track down the change in stability. Some options in ContinuationPar control this behavior:\n\nn_inversion: number of sign inversions in the bisection algorithm\nmax_bisection_steps maximum number of bisection steps\ntol_bisection_eigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps\n\nIf this is still not enough, you can use a Newton solver to locate them very precisely. See Fold / Hopf Continuation.\n\ntip: Bisection mode\nDuring the bisection, the eigensolvers are called like eil(J, nev; bisection = true) in order to be able to adapt the solver precision.","category":"section"},{"location":"detectionBifurcation/#Large-scale-computations","page":"Bifurcation detection (codim 1)","title":"Large scale computations","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).\n\n[1]: In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"section"},{"location":"detectionBifurcation/#List-of-detected-bifurcation-points","page":"Bifurcation detection (codim 1)","title":"List of detected bifurcation points","text":"Bifurcation index used\nFold fold\nHopf hopf\nBifurcation point (single eigenvalue stability change, Fold or branch point) bp","category":"section"},{"location":"detectionBifurcation/#Eigensolver","page":"Bifurcation detection (codim 1)","title":"Eigensolver","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where NewtonOptions is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.\n\nThe eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"section"},{"location":"detectionBifurcation/#Generic-bifurcation","page":"Bifurcation detection (codim 1)","title":"Generic bifurcation","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.\n\nThe detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. ","category":"section"},{"location":"detectionBifurcation/#Fold-bifurcation","page":"Bifurcation detection (codim 1)","title":"Fold bifurcation","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.\n\nThe detection is triggered by setting detect_fold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.foldpoint allowing for later refinement using the function newtonFold.","category":"section"},{"location":"detectionBifurcation/#Hopf-bifurcation","page":"Bifurcation detection (codim 1)","title":"Hopf bifurcation","text":"The detection of Branch point is done by analysis of the spectrum of the Jacobian.\n\nThe detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. When a Hopf point is detected, a point is added to br.specialpoint allowing for later refinement using the function newton_hopf.","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/#Hutchinson-with-Diffusion","page":"Hutchinson with Diffusion","title":"Hutchinson with Diffusion","text":"Pages = [\"HutchinsonDiff.md\"]\nDepth = 3\n\nConsider the Hutchinson equation with diffusion\n\nbeginaligned\n fracpartial u(t x)partial t=d fracpartial^2 u(t x)partial x^2-a u(t-1 x)1+u(t x) quad t0 x in(0 pi) \n fracpartial u(t x)partial x=0 x=0 pi\nendaligned\n\nwhere a0 d0. ","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/#Problem-discretization","page":"Hutchinson with Diffusion","title":"Problem discretization","text":"We start by discretizing the above PDE based on finite differences.\n\nusing Revise, DDEBifurcationKit, Plots, SparseArrays, LinearAlgebra\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction Hutchinson(u, ud, p)\n   (; a, d, Î”) = p\n   d .* (Î” * u) .- a .* ud[1] .* (1 .+ u)\nend\n\ndelaysF(par) = [1.]\nnothing #hide","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/#Bifurcation-analysis","page":"Hutchinson with Diffusion","title":"Bifurcation analysis","text":"We can now instantiate the model\n\n# discretisation\nNx = 200; Lx = pi/2;\nX = -Lx .+ 2Lx/Nx*(0:Nx-1) |> collect\nh = 2Lx/Nx\nÎ” = spdiagm(0 => -2ones(Nx), 1 => ones(Nx-1), -1 => ones(Nx-1) ) / h^2; Î”[1,1]=Î”[end,end]=-1/h^2\nnothing #hide\n\nWe are now ready to compute the bifurcation of the trivial (constant in space) solution:\n\n# bifurcation problem\npars = (a = 0.5, d = 1, Ï„ = 1.0, Î” = Î”, N = Nx)\nx0 = zeros(Nx)\n\nprob = ConstantDDEBifProblem(Hutchinson, delaysF, x0, pars, (@optic _.a))\n\noptn = NewtonPar(eigsolver = DDE_DefaultEig())\nopts = ContinuationPar(p_max = 10., p_min = 0., newton_options = optn, ds = 0.01, detect_bifurcation = 3, nev = 5, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob, PALC(), opts; verbosity = 0, plot = false, normC = norminf)\nbr\n\nWe note that the first Hopf point is close to the theoretical value a=fracpi 2. This can be improved by increasing opts.n_inversion.\n\nWe can now plot the branch\n\nscene = plot(br)","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/#Performance-improvements","page":"Hutchinson with Diffusion","title":"Performance improvements","text":"The previous implementation being simple, it leaves a lot performance on the table. For example, the jacobian is dense because it is computed with automatic differentiation without sparsity detection. \n\nWe show how to specify the jacobian and speed up the code a lot.\n\n# analytical jacobian\nfunction JacHutchinson(u, p)\n   (;a, d, Î”) = p\n   # we compute the jacobian at the steady state\n   J0 = d * Î” .- a .* Diagonal(u)\n   J1 = -a .* Diagonal(1 .+ u)\n   return J0, [J1]\nend\n\nprob2 = ConstantDDEBifProblem(Hutchinson, delaysF, x0, pars, (@optic _.a); J = JacHutchinson)\n\noptn = NewtonPar(eigsolver = DDE_DefaultEig())\nopts = ContinuationPar(p_max = 10., p_min = 0., newton_options = optn, ds = 0.01, detect_bifurcation = 3, nev = 5, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob2, PALC(), opts; verbosity = 1, plot = true, normC = norminf)\nbr","category":"section"},{"location":"tutorials/dde/HutchinsonDiff/#References","page":"Hutchinson with Diffusion","title":"References","text":"","category":"section"},{"location":"tutorials/dde/neuron/#Neuron-model-(codim-2,-periodic-orbits)","page":"Neuron model (codim 2, periodic orbits)","title":"Neuron model (codim 2, periodic orbits)","text":"Pages = [\"neuron.md\"]\nDepth = 3\n\nConsider the neuron model\n\nleftbeginarrayl\ndotx_1(t)=-kappa x_1(t)+beta tanh left(x_1left(t-tau_sright)right)+a_12 tanh left(x_2left(t-tau_2right)right) \ndotx_2(t)=-kappa x_2(t)+beta tanh left(x_2left(t-tau_sright)right)+a_21 tanh left(x_1left(t-tau_1right)right)\nendarrayright","category":"section"},{"location":"tutorials/dde/neuron/#Continuation-and-codim-1-bifurcations","page":"Neuron model (codim 2, periodic orbits)","title":"Continuation and codim 1 bifurcations","text":"We first instantiate the model\n\nusing Revise, DDEBifurcationKit, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction neuronVF(x, xd, p)\n   (; Îº, Î², a12, a21, Ï„s, Ï„1, Ï„2) = p\n   [\n      -Îº * x[1] + Î² * tanh(xd[3][1]) + a12 * tanh(xd[2][2]),\n      -Îº * x[2] + Î² * tanh(xd[3][2]) + a21 * tanh(xd[1][1])\n   ]\nend\n\ndelaysF(par) = [par.Ï„1, par.Ï„2, par.Ï„s]\n\npars = (Îº = 0.5, Î² = -1, a12 = 1, a21 = 0.5, Ï„1 = 0.2, Ï„2 = 0.2, Ï„s = 1.5)\nx0 = [0.01, 0.001]\n\nprob = ConstantDDEBifProblem(neuronVF, delaysF, x0, pars, (@optic _.Ï„s))\n\noptn = NewtonPar(eigsolver = DDE_DefaultEig(maxit=200))\nopts = ContinuationPar(p_max = 13., p_min = 0., newton_options = optn, ds = -0.01, detect_bifurcation = 3, nev = 5, dsmax = 0.2, n_inversion = 4)\nbr = continuation(prob, PALC(), opts; verbosity = 0, plot = true, bothside = true, normC = norminf)\n\nWe then plot the branch\n\nscene = plot(br)","category":"section"},{"location":"tutorials/dde/neuron/#Normal-forms-computation","page":"Neuron model (codim 2, periodic orbits)","title":"Normal forms computation","text":"As in BifurcationKit.jl, it is straightforward to compute the normal forms.\n\nhopfpt = BK.get_normal_form(br, 2)","category":"section"},{"location":"tutorials/dde/neuron/#Continuation-of-Hopf-points","page":"Neuron model (codim 2, periodic orbits)","title":"Continuation of Hopf points","text":"We follow the Hopf points in the parameter plane (a_21tau_s). We tell the solver to consider br.specialpoint[3] and continue it.\n\n# continuation of the first Hopf point\nbrhopf = continuation(br, 3, (@optic _.a21),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.04, max_steps = 230, p_max = 15., p_min = -1.,ds = -0.02);\n         detect_codim2_bifurcation = 2,\n         # bothside = true,\n         start_with_eigen = true)\n\n# continuation of the second Hopf point\nbrhopf2 = continuation(br, 2, (@optic _.a21),\n         ContinuationPar(br.contparams, detect_bifurcation = 1, dsmax = 0.1, max_steps = 56, p_max = 15., p_min = -1.,ds = -0.01, n_inversion = 4);\n         detect_codim2_bifurcation = 2,\n         start_with_eigen = true,\n         bothside=true)\n\nscene = plot(brhopf, brhopf2, legend = :top)","category":"section"},{"location":"tutorials/dde/neuron/#Branch-of-periodic-orbits","page":"Neuron model (codim 2, periodic orbits)","title":"Branch of periodic orbits","text":"We change the continuation parameter and study the bifurcations as function of a_21.\n\nprob2 = ConstantDDEBifProblem(neuronVF, delaysF, x0, pars, (@optic _.a21))\nbr2 = BK.continuation(prob2, PALC(), ContinuationPar(opts, ds = 0.1, p_max = 3., n_inversion = 4); verbosity = 0, plot = false, normC = norminf)\n\nWe then compute the branch of periodic orbits from the Hopf bifurcation points using orthogonal collocation.\n\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.1, ds= -0.0001, dsmin = 1e-4, p_max = 10., p_min=-0., max_steps = 120, detect_bifurcation = 0, save_sol_every_step=1)\n@reset opts_po_cont.newton_options.tol = 1e-8\n@reset opts_po_cont.newton_options.verbose = false\n\n# arguments for periodic orbits\nargs_po = (\trecord_from_solution = (x, p; k...) -> begin\n\t\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\t\treturn (max = maximum(xtt[1,:]),\n\t\t\t\t\tmin = minimum(xtt[1,:]),\n\t\t\t\t\tperiod = getperiod(p.prob, x, nothing))\n\t\tend,\n\t\tplot_solution = (x, p; k...) -> begin\n\t\t\txtt = BK.get_periodic_orbit(p.prob, x, nothing)\n\t\t\tplot!(xtt.t, xtt[1,:]; label = \"V1\", k...)\n\t\t\tplot!(xtt.t, xtt[2,:]; label = \"V2\", k...)\n\t\t\tplot!(br2; subplot = 1, putspecialptlegend = false)\n\t\t\tend,\n\t\tnormC = norminf)\n\nprobpo = PeriodicOrbitOCollProblem(60, 4; N = 2, jacobian = BK.AutoDiffDense())\nbr_pocoll = @time continuation(\n\tbr2, 1, opts_po_cont,\n\tprobpo;\n\tverbosity = 0,\tplot = false,\n\targs_po...,\n\tÎ´p = 0.003,\n\tnormC = norminf,\n\t)\nscene = plot(br2, br_pocoll)\n\nWe can plot the periodic orbit as they approach the homoclinic point.\n\nscene = plot(layout = 2)\nfor ii = 1:10:110\n\tsolpo = BK.get_periodic_orbit(br_pocoll.Î³.prob.prob, br_pocoll.sol[ii].x, nothing)\n\tplot!(scene, solpo.t ./ solpo.t[end], solpo.u[1,:], label = \"\", subplot = 1)\nend\nxlabel!(scene, \"t / period\", subplot = 1)\nplot!(scene, br_pocoll, vars = (:param, :period), subplot = 2, xlims=(2.2,2.4))\nscene","category":"section"},{"location":"tutorials/dde/neuron/#References","page":"Neuron model (codim 2, periodic orbits)","title":"References","text":"","category":"section"},{"location":"BifProblem/#Bifurcation-Problem","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"","category":"section"},{"location":"BifProblem/#Constant-delays-(DDE)","page":"Bifurcation Problem","title":"Constant delays (DDE)","text":"Consider the system of delay differential equations with constant delays (DDEs)\n\nfracmathrmdmathrmd t x(t)=mathbf Fleft(x(t) xleft(t-tau_1right) ldots xleft(t-tau_mright) pright)\n\nwhere the delays tau_i0 are constant and p is a set of parameters. In order to specify this, we need to provide the vector field and the delays. The delays are provided using a delay function which must return an AbstractVecor\n\nfunction mydelays(pars)\n\t[1, pars.tau1]\nend\n\nwhere pars are some user defined variables. The vector field is then specified as follows\n\nfunction myF(x, xd, pars)\n\t[\n\t\tx[1] + xd[2][1]^2,\n\t\tx[2] + xd[3][2]^2,\n\t]\nend\n\nwhere xd is a vector holding [x(t-d[1]), x(t-d[2])] where d = mydelays(pars). Some simple examples can be found in the tutorials.\n\nThe structure ConstantDDEBifProblem encapsulates the bifurcation problem.","category":"section"},{"location":"BifProblem/#State-dependent-delays-(SD-DDE)","page":"Bifurcation Problem","title":"State-dependent delays (SD-DDE)","text":"Consider the system of delay differential equations with state-dependent delays.\n\nfracmathrmdmathrmd t x(t)=mathbf Fleft(x(t) xleft(t-tau_1(x(t))right) ldots xleft(t-tau_m(x(t))right) pright)\n\nwhere the delays tau_i0 are functions of x(t) and p is a set of parameters. The only difference with the previous case is the specification of the delay function which now depends on x\n\nfunction mydelays(x, pars)\n\t[\n\t\t1 + x[1]^2,\n\t\t2 + x[2]^2\n\t]\nend\n\nThe structure SDDDEBifProblem encapsulates the bifurcation problem.\n\nA more elaborate problem would be to allow tau_i to depend on the history of x(theta+t) for thetain-tau_max0 and not just on the current value of x(t). This is not implemented yet.","category":"section"},{"location":"periodicOrbitCollocation/#Periodic-orbits-based-on-orthogonal-collocation","page":"Collocation","title":"Periodic orbits based on orthogonal collocation","text":"We compute Ntst time slices of a periodic orbit using orthogonal collocation. This is implemented in the structure BifurcationKit.PeriodicOrbitOCollProblem.\n\nwarning: Large scale\nThe current implementation is not yet optimized for large scale problems. This will be improved in the future.\n\nwarning: Floquet coefficients\nThe current implementation does not yet allow for computing stability of periodic orbits. This will be improved in the future.  \n\nThe general method is explained in BifurcationKit.jl.","category":"section"},{"location":"#DDEBifurcationKit.jl","page":"Home","title":"DDEBifurcationKit.jl","text":"This Julia package aims at performing automatic bifurcation analysis of possibly large dimensional equations delay differential equations (DDE) by taking advantage of iterative methods, dense / sparse formulation and specific hardwares (e.g. GPU).\n\nIt builds upon BifurcationKit.jl with version > 0.2 to perform continuation and numerical bifurcation analysis.","category":"section"},{"location":"#Installation","page":"Home","title":"ðŸ“¦ Installation","text":"Assuming that you already have Julia correctly installed, it suffices to add DDEBifurcationKit.jl in the standard way:\n\n] add DDEBifurcationKit.jl","category":"section"},{"location":"#Citing-this-work","page":"Home","title":"ðŸ“š Citing this work","text":"If you use this package for your work, we ask that you cite the following paper!! Open source development strongly depends on this. It is referenced on HAL-Inria with bibtex entry CITATION.bib.","category":"section"},{"location":"#Other-softwares","page":"Home","title":"ðŸ§‘â€ðŸ’» Other softwares","text":"There are several good softwares already available.\n\nFor continuation in small dimension, most softwares are listed on DSWeb. One can mention the widely used DDE-BIFTOOL, Knut. All these are very reliable and some address high codimension bifurcations.\nFor large scale problems, there is very little.\n\nIn Julia, the present package seems to be the only one.","category":"section"},{"location":"#A-word-on-performance","page":"Home","title":"A word on performance","text":"The examples which follow have not all been written with the goal of performance but rather simplicity (for now).","category":"section"},{"location":"#Main-features","page":"Home","title":"Main features","text":"Newton-Krylov solver with generic linear / eigen preconditioned solver. Idem for the arc-length continuation.\nNewton-Krylov solver with nonlinear deflation and preconditioner. It can be used for branch switching for example.\nContinuation written as an iterator\nMonitoring user functions along curves computed by continuation, see events.\nContinuation methods: PALC, Moore-Penrose, etc. See methods.\nBifurcation points are located using a bisection algorithm\ndetection of Branch, Fold, Hopf bifurcation point of stationary solutions and computation of their normal form.\n\n<ul> \n<li><del>Automatic branch switching at branch points (whatever the dimension of the kernel)</del></li></ul>\n\nAutomatic branch switching at simple Hopf points to periodic orbits\nAutomatic bifurcation diagram computation of equilibria\nFold / Hopf continuation.\n\n<ul> \n<li>detection all codim 2 bifurcations of equilibria and <del>computation of the normal forms of Bogdanov-Takens, Bautin and Cusp</del></li>\n<li><del>Branching from Bogdanov-Takens points to Fold / Hopf curve</del></li>\n<li>Periodic orbit computation and continuation using <del>Shooting, Finite Differences or </del>Orthogonal Collocation.</li>\n<li><del>detection of Branch, Fold, Neimark-Sacker, Period Doubling bifurcation point of periodic orbits.</del></li>\n<li><del>Continuation of Fold of periodic orbits</del></li>\n</ul>\n\nCustom state means, we can use something else than AbstractArray, for example your own struct.\n\nType of delay: Constant (C), state-dependent (SD), nested (N)\n\nFeatures delay type Matrix Free Custom state Tutorial GPU\n(Deflated) Krylov-Newton C/SD Yes Yes  \nContinuation PALC (Natural, Secant, Tangent, Polynomial) C/SD    \nBifurcation / Fold / Hopf point detection C/SD Y   \nFold Point continuation C/SD Y   \nHopf Point continuation C/SD  AbstractArray  \n~~Bogdanov-Takens Point newton~~ C/SD Y AbstractArray  \nBranch point / Fold / Hopf normal form C/SD Y   \nBranch switching at Branch / Hopf points C/SD Y AbstractArray  \n<span style=\"color:red\">Automatic bifurcation diagram computation of equilibria</span> C/SD Y AbstractArray  \n~~Periodic Orbit (Trapezoid) Newton / continuation~~   AbstractVector  \nPeriodic Orbit (Collocation) Newton / continuation C/SD  AbstractVector  \n~~Periodic Orbit (Parallel PoincarÃ© / Standard Shooting) Newton / continuation~~   AbstractArray  \n~~Fold, Neimark-Sacker, Period doubling detection~~   AbstractVector  \n~~Continuation of Fold of periodic orbits~~   AbstractVector  \nBogdanov-Takens / Bautin / Cusp / Zero-Hopf / Hopf-Hopf point detection C/SD Y   \n~~Bogdanov-Takens / Bautin / Cusp / Zero-Hopf / Hopf-Hopf normal forms~~  Y   \n~~Branching from Bogdanov-Takens points to Fold / Hopf curve~~   AbstractVector  ","category":"section"},{"location":"#Requested-methods-for-Custom-State","page":"Home","title":"Requested methods for Custom State","text":"Needless to say, if you use regular arrays, you don't need to worry about what follows.\n\nWe make the same requirements as KrylovKit.jl. Hence, we refer to its docs for more information. We additionally require the following methods to be available:\n\nBase.length(x): it is used in the constraint equation of the pseudo arclength continuation method (see continuation for more details). If length is not available for your \"vector\", define it length(x) = 1 and adjust tuning the parameter theta in ContinuationPar.\nBase.copyto!(dest, in) this is required to reduce the allocations by avoiding too many copies\nBase.eltype must be extended to your vector type. It is mainly used for branching.","category":"section"},{"location":"#Citations","page":"Home","title":"Citations","text":"The papers citing this work are collected on google scholar.","category":"section"}]
}
